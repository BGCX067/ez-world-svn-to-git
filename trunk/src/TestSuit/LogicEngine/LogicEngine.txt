最小化实验
	地图定义
		掉落的箱子
		角色
		技能区域
		动态碰撞
		功能点，功能区域管理
		
	角色基本外观信息
	角色移动、站立状态改变
	角色位置改变
	怪物分布(无AI)
	玩家物理攻击
	角色属性改变发送
	装备&装备栏(只做影响,不更换装备.)

	角色装备外观
	玩家施放技能
	装备更换&背包
	怪物物品掉落	

	地图区域buff
	虚拟时间buff
	GM手工buff

	消息量优化。
	、服务器只推送移动消息，和视觉范围内的位置信息。客户端对于未知可视信息的角色向服务器查询。
	、地图分区采取5*5便于Lod,还是采取3*3用计算去Lod?
	
	服务器构架完善
	、多网关，多地图服务器。
	、当服务器组不完备时，网关拒绝新玩家登陆，但是不中断仍可继续游戏的玩家。
	、去掉数据库服务器，改为数据缓存服务器。逻辑服务器与数据缓存服务器沟通，只在初始化时等回馈，其他更改只发送。
	、逻辑服务器的PacketLogger
	
	逻辑由硬编码向编辑器和更好的设计模式转移。	
	、角色状态的定义，服务器客户端使用同样的状态定义
	、采取观察者的模式，不再在逻辑代码中写发送的代码。而是每帧比较是否有改变，向观察者去发送信息。
	、去掉客户端与服务器沟通时角色需要的可视信息硬编码。让单元定义的观察者关心的字段真正起作用。(针对观察者的传送数据块自动生成)
	、逻辑引擎内含固定的虚类定义。
		mapobj(x,y,z,mapid)
		moveable_mapobj(+speed)
		item(最大叠加数量，当前叠加数量，判断是否同一物品的回调)
	、编辑器增加对状态改变，属性字段改变的回调事件。
	
	客户端逻辑数据与界面、3D显示彻底分离。
	、逻辑数据界面绑定。
	、逻辑数据3D图形绑定。
	、物品tips采取xml + xsl

	代码规范
	、为平台可移植性做准备。
	、引入log4cplus	
	、引入cppunit或者googletest
	、引入UML设计图。至少是时序图。类图。

单元定义

数据定义
限制定义(固定无须定义)
影响定义(固定无须定义)
BUFF定义(固定无须定义)
状态机定义(暂时作为数据的一部分)
容器定义

数据模板(玩家不需要数据模板)
限制模板
影响模板
BUFF模板
状态机模板(无须模板)
容器模板(无须模板)

数据实例
限制实例
影响实例
BUFF实例
状态机实例(暂时作为数据的一部分)
容器实例

如何设计接口,访问实例的相应实例

技能实例与所有被技能影响的人建立了联系。
	期间技能的每个Buf失效都会导致所有联系中的人重新计算。	

容器
	实例容器	存储实例ID	例如:背包,仓库
	模板容器	存储 单元ID+模板ID	例如:已学会的技能.已获得的称号.
	快捷容器	存储 单元ID+模板ID+实例容器来源 并有统计相应实例的作用. 例如:快捷栏.
	
	标记寄存器	存储单纯的0/1标记	例如:全局任务标记.

	事件寄存器
		事件ID
		事件历史标记X32(不可反复标记)
		选择历史标记X32(不可反复标记)
		用户标记X32(可反复标记)
		计数器X4
		计时器X1

	容器的特定限制。（背包仓库无限制，装备的格子是限制物品类型的）		
		
一个实例可能会对多个实例产生影响。为了便于计算，被影响的实例是需要保存影响了自己的所有来源。(影响或者Buf)
	产生了影响的实例也要保存自己所影响的实例列表。


事件定义
	实例数值改变
		1.数据属性域改变.
		2.状态机改变.
		3.容器内容改变.
		4.操作开始、操作结束。

继承基类的数据，状态机，
	

LogicHeader{LOGIC_FLAG,LOGIC_VER};
[NODE]
	LogicHeader{NODE_FLAG,NODE_VER};
	NodeDesc{
		Node_Type	m_eType;
		TCHAR		m_szName[MAX_NAME];
		BOOL		m_bFiled;
		BOOL		m_bExclusive;
		BOOL		m_bLeaf;
	}

	[TREE:]
		UINT nChildren
		[NODE:] * nChildren;
	[LEAF:]
		LeafNodeDesc{
			UINT nRows;
			UINT nRowLength;
		}	
		[ROWS]
			[ROW]
				BYTE byRow[nRowLength]
					[Enum]
						UINT nEnum
						lpszEnum[MAX_NAME][nEnum]
					[FieldId]
						FieldIdDesc


针对所有的装备和BUF的数值计算
	这部分只考虑已经建立了联系的装备和已经附加上的BUF.对于BUF的数量限制规则和替换规则,在另外部分讨论.
	单元和单元之间的关系 不同的关系可能会导致不同的加成方案.
	扩充加成表
		模板		属于哪个物品模板的加成
		关系类型	属于哪种关系
		目标单元	加成是针对关系链上的哪个单元的
		目标元素	状态机,位置,物品空间 基本属性 加成 需求	
		目标字段	具体加成的目标字段
		目标阶段(扩)原始值 当前值 用户自定义
		操作类型	扩充类型(扩):脚本操作
		操作值		脚本操作中操作值是一段脚本(扩).脚本中可以做条件判断,针对不同的条件产生不同的值.也可以扩充除预先定义好的操作类型外的计算. 
				可以把预定的操作方式都作为脚本的特例.
				这样操作方式就变成了影响操作脚本的编号
				同种影响操作脚本的
		作用条件(扩)条件满足,此加成才起作用.只做 True 和 false 	判断
		加成表中的脚本要针对唯一的字段,不允许对多个字段操作.
	单元基本属性的计算
		根据属性的依赖性,做一个排序:最基本的属性最先计算,依赖最多的属性最后计算,以保证字段依赖的字段都是被计算好的.	
		每个属性都需要一个计算公式.当有属性值改变时(装卸装备,BUF附加消失,升级,被物理攻击,即时物品使用),所有的属性都被重新计算.
		每个属性的计算公式可以是公用的,也可以是特殊的.
		计算公式涉及到的因素
			目标字段
			目标阶段
			操作类型
			操作值
		计算公式是针对每个属性字段,每个物品实例写的.在每个字段计算每个物品实例都要被调用一次.
			基本属性[目标字段][目标阶段] = 
			
		
cWorld
	cWorldImp
	
cNodeDesc
	cTreeNodeDesc
		cTreeNodeDesc_imp
	cLeafNodeDesc
		cLeafNodeDesc_Imp
			cTemplateLeafNodeDesc
cBaseNode
	cTreeNode
		cTreeNode_Imp
			?cUnitTreeNode_Imp
	cLeafNode
		cLeafNode_Imp
			cAttribLeafNode
			cTemplateLeafNode








角色
建筑
NPC
武器
弹药
装备道具
使用道具
地图

NPC模型
武器模型

升级经验
NPC组合
地图刷新
路点行为
地图派兵
全局变量
卡片随机
道具掉落
	
	Unit_Player,		// 玩家					有外观	由玩家控制
	Unit_Ai,			// NPC					有外观	由AI控制
	Unit_Item,			// 物品					有外观	无行为

	Unit_Bag,			// 物品空间				
	Logic::Unit_Map,			// 游戏地图的切换单位	
	Unit_Area,			// 特殊单元属性的集合	具有属性的地图区域
	Unit_Grid,			// 游戏地图的最小单元	地图格子	每个地图格子都是有属性的。通常地图格子都可以分成几类。	

	Unit_Container,		// 个体容器类联合	团队/门派/怪物群落
	Unit_Contact,		// 个体关联类集合	好友
	Unit_TempEffect,	// 临时效果物品

对照表	



如果只有唯一索引
	有自动编号行，则不能随意插入
	只在行 之间有编号空挡的时候才可以插入
	设置编号开始值。改变后整个表都改变。
如果是非唯一索引或者
	

1、行对象的添加和删除需要重新排行号
2、树状表的显示
3、输入Excel的格式。
	格式中到底包含哪些因素
		网格
			字体
			背景颜色
				FixRow 的颜色 跟随 Excel 的设定
				只有颜色不能设置图案
			对齐方式
			
			边框只能整体设置。
			
		Excel
			字体
			背景颜色
			对齐方式
			
			

不能指望策划一次定义就是完善的。反复修改是不可避免的。
所以直接采取第2种世界树结构。流程图作为另外的文档给出，编辑器不表现制作流程。

1、世界树结构的问题
	用单元管理去刷新单元定义树	整体刷新
		添加类
		删除类
	用数据属性刷新数据模板？
	去掉添加世界节点的菜单选项				
	暂时先不涉及 单元是否剧本状态，操作。
		去掉标记表，增加标记变量？
			f &= ~a
			状态+指令+进出脚本
			有些类没有 状态，操作
		简化模型
			世界
				单元管理
				单元数据
					单元1
						数据属性
						数据模板	
		允许不能实例化的单元。去掉全局表。单元和全局表统一对待。
		叶节点增加是否可实例化属性。
		
	
	如果是模板类型的叶节点，则自己分配自己的描述，析构时释放掉。
	把当前节点存为XML，	再读出来。
	
	枚举另存为全局表
		如果在枚举表中指明是哪个单元的哪个域，在域中就不必另外说明了。
		枚举中设置 某表的列
		原来的文件格式可以导入。
	
	删除和剪切后，如何删除多余的行
		ResizeRows();
		
		
2、树状表的显示，索引域到下个索引域之间的域，跟随前一个。
	在编辑的时候，在哪个区域就按照哪个层次去添加/删除/编辑。
3、地图刷新表 和 路点行为表
	地图ID
	阶段ID
	最大刷新组
	最小刷新组
	刷新频率
	兵种组ID
	兵种组几率

	地图ID
	兵种ID
	路点级别
	行为
4、行对象作为指针直接返回
5、行对象的调试信息
6、行的添加（到最后），删除操作
7、查询方式是否简化到不需要列名？
	索引域不一定是在一起的。中间可能间隔其他列。
	标记键顺序值仍然是需要的。
	
	所以就不再需要列名了。
8、状态对属性的影响
	状态	目标属性域	影响脚本
	因为脚本包括了一切可能性 所以不再考虑其他简化方式了。
	脚本在表格中如何表现
		可以直接编辑。双击弹出编辑窗口。
** 从语言的角度考虑

关系模板
	针对每个域还是综合？
		就限制来说
			针对域比综合有利于模板生成规则
			综合比针对域有利于手动指定规则
			对属性域的要求是与不可能出现或？
		就结果来说			
			物品结果是确定的，不会有
	目标	关系	限制/结果	属性域	公式


以其他字段为数组索引，查找本字段的数据填写方式
	基本类型
		字符串	str
		整数	int
		枚举	enum 
			枚举可以是填写指定的 
			也可以对应到 单索引表 的索引列（只有索引列才可保证数据是不重复的） 并自动增加 -1(无)
				索引列的枚举，使用表列的项目做描述
			枚举名:枚举项
		布尔	bool
		
	概率值
		概率值的结果可以是任何基本类型，但必须是单一类型
		概率值必须声明使用的基本类型
		int random 
		enum random	
		bool random
	结构
		结构的组成可以是任何基本类型
		结构必须有定义。
	表[][]...[]
		不同于高级语言里的数组，这里的表，索引总是有意义的。
			int table 职业速度表[职业] = {职业1:10,职业2:20,职业3:30,职业4:40};
			int table 职业状态速度表[职业][状态] =	{状态1:{职业1:10,职业2:20,职业3:30,职业4:40},
								状态2:{职业1:10,职业2:20,职业3:30,职业4:40},	
								状态3:{职业1:10,职业2:20,职业3:30,职业4:40}}	
		表项可以是任何基本类型/概率值/结构/表，但必须是单一类型	
		表项必须声明使用的基本类型

但他除了是一门语言，还有一部分预定的逻辑在内。

===========================================================================================
问题1、定义树的结构


方案一、按照流程顺序
世界
	单元管理			网格
	单元定义
		单元1
			数据属性	网格	
			数据计算	脚本
			状态机
	关系定义			网格
	单元模板
		单元1
			数据模板	网格
			关系模板	网格
	操作定义
		单元1
	全局表


方案二、按照单元组分类
世界
	单元管理
	单元数据
		单元1
			数据属性
			数据模板	
			关系模板
			数据计算
			状态机
			操作定义
	关系定义
	全局表
		定义1
		数据1
	



===========================================================================================
问题2、叶节点的结构

[单元管理]2D网格（单字段索引）	表格[单元名]
		单元名	类别	位置类型	使用角度	空间类型	说明
		[类别]	
[数据属性]2D网格（单字段索引）	表格[字段名]
		字段名	显示名	来源	类型	最小值	最大值	长度	说明
		[来源]	基本数值	计算衍生	全局变量
		[类型]	字符串	整数	枚举	布尔
[状态表]2D网格（单字段索引）	表格[状态名]
		状态名	持续时间	说明
[指令表]2D网格（双字段索引）	表格[指令名][源状态]
		指令名	源状态	目标状态
		*采取全局指令方式，每个指令都可以在任何状态发出，但是有些状态可能不响应。
		*不采取与状态对应的指令方式
[状态影响]2D网格（双字段索引）	表格[目标属性域][状态]
		状态	目标属性域	影响方式	影响值	说明
[标记定义]2D网格（单字段索引）	表格[标记名]
		标记名	持续时间	说明
[数据模板]2D网格（双字段索引，表格[ID字段][目标字段]）
		ID字段		目标字段	基本值		浮动方式	浮动数值
		[浮动方式]	无	范围	范围几率表	数值几率表
[关系模板]2D网格（三字段索引，表格[关系名][限制/加成][目标字段])
	关系名	目标物体	加成/限制	目标字段	脚本	出现几率（创建规则）
[操作限制]
	每个操作元单独的限制
	操作元关系限制

网格类			描述来源		枚举来源		索引字段
	固定网格	硬编码			硬编码
	数据模板网格	数据属性定义表格	数据属性定义表格
	状态指令网格	硬编码			状态表定义表格

表格分为 单字段索引 双字段索引 n字段索引	实际上就是几维数组的问题
	双字段索引的表格，都可以有两种表现方式。
		1 把两个索引字段都作为列
		=================================================
		ID字段 | 目标字段 | 基本值 | 浮动方式 |	浮动数值 
		-------------------------------------------------
		
		2 第一索引作为列 第二索引作为第一固定行,其他内容作为活动行.
		=============================================================
			|	目标字段一	  |	目标字段二	    |
		ID字段	+-------+--------+--------+-------+--------+--------+
			|基本值	|浮动方式|浮动数值|基本值 |浮动方式|浮动数值|
		-------------------------------------------------------------
	

===========================================================================================
1、状态机
	.状态随时间变化,作为状态本身的属性
	.指令集与状态的对照表.
		可以理解为全局指令表,也可以理解为每个状态都有自己的指令表
	.对于机关类单元，可以在类中声明数个状态机。
		只是实例中，用不到的状态机一直被处于常态。	
2、联系
	对域的作用
	目标	作用方式	作用值
		数值加		数值			
		百分比加	数值
		缩放		数值
		替换		数值或者字符串
		合并		数值或者字符串
		公式		正则表达式
		查表		表项
	对域的限制
	目标	限制方式		

	联系方式
		物品空间
		真实空间
			地图&lt;-&gt;地图上的人
			伤害/事件区域&lt;-&gt;区域内的人
		团体组织
		创建者
			因为这层关系，可保持临时单元与创建者之间的联系。
	
	加成不但可以针对基本数据域，也可以另加成目标产生出新的影响
		例如
			实例A 本来对 实例B 无影响。
			但是因为A装备C实例 ，就导致 A对B有了影响。

		为了避免多级别关系链的计算，避免对兄弟节点影响的计算
			把所有问题都归结为自己父节点或子节点的影响。		

		创建一个区域（伤害或事件）
			进入区域的人与这个区域建立联系。
			这个区域可以是放在地图上的（静态区域 父节点是地图）
			也可以是跟随创建者的（动态区域 父节点是创建者）
				位置跟随父节点吗？

	建立联系
		装卸	持久的可装卸影响
		附着	间隔的重复不可装卸影响
	使用
		
3、模板
	同一类物体，有几种可用模板对应不同的操作。
	如何指定哪些域是可变化的？哪些域是不可变化的？
	如何指定在针对某类物品的关系时，每个属性域可出现的几率？

	一类物品可以有数套模板？
		基本数值 + 可变因素
	生成物品时指定模板名。	
	

	创建规则
		决定哪些数据是可以随机的。
		决定哪些关系的出现是有比例的。
			数据模板中的一行，只能对应一个创建规则。如果创建规则不同，可以认为是另一个模板了。
			既然是一一对应，应该是可以写在数据模板和关系模板中。

4、操作
	条件
		位置/角度、体积/容积是否许可
		状态是否许可
		数据属性是否许可
		标志是否许可
	效果
		状态转换 导致的数值改变

	一个全局的 操作/状态 互斥表？

	Unit_Pos,			// 空间位置限制
	Unit_Attrib,			// 数据属性限制
	Unit_State,			// 当前状态限制
	Unit_Flag,			// 当前标记限制
	Unit_Space,			// 当前空间大小属性限制

	Unit_Relation,			// 当前关系链限制
	Unit_Effect,			// 当前影响限制
	Unit_Limit,			// 当前限制限制
5、特殊数据类型：
	表。
		编辑时可不必输入长度
	几率表。
		
6、增加全局变量节点。

=============================================================================
地图1
	路点行为
		兵种1	路点1	行为1
		兵种1	路点2	行为2

定义表(转换成2D表)
	[兵种][地图][路点等级][行为][攻击目标]	整个表最后返回一个值
	兵种组合表

问题
	0、程序与策划的接口，
		1、行为的定义。
		2、AI数据结构的定义。
	1、可以为每个单元类自由添加AI数据表？
		每个单元类，还是每个数据模板？
			需要让用户指定枚举的来源。
				缺陷：仍然有些数据无法保证有效性。
		
		

	1、地图中的兵种组合。
		刷新是地图的一个操作。
			这个操作需要地图的一个属性。这个属性的类型是：随机数组。
				数组 + 随机函数	 vs	随机数组
	2、地图中的兵种行为定义表
		路点行为是兵种的一个操作。这个操作需要兵种的一个属性。这个属性是个枚举类型。
			路点对兵种行为的影响是一个联系。
				地图对路点的行为的影响是一个联系


