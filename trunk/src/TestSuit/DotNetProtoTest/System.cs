// Generated by ProtoGen, Version=2.4.1.473, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace core {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public static partial class System {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_core_GUID__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::core.GUID, global::core.GUID.Builder> internal__static_core_GUID__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_core_Base__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::core.Base, global::core.Base.Builder> internal__static_core_Base__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_core_BaseItem__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::core.BaseItem, global::core.BaseItem.Builder> internal__static_core_BaseItem__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_core_Position__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::core.Position, global::core.Position.Builder> internal__static_core_Position__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_core_MoveAble__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::core.MoveAble, global::core.MoveAble.Builder> internal__static_core_MoveAble__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_core_Rect__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::core.Rect, global::core.Rect.Builder> internal__static_core_Rect__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_core_Point__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::core.Point, global::core.Point.Builder> internal__static_core_Point__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_core_PointF__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::core.PointF, global::core.PointF.Builder> internal__static_core_PointF__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_core_LimitValue__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::core.LimitValue, global::core.LimitValue.Builder> internal__static_core_LimitValue__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_core_Limits__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::core.Limits, global::core.Limits.Builder> internal__static_core_Limits__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_core_EffectValue__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::core.EffectValue, global::core.EffectValue.Builder> internal__static_core_EffectValue__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_core_EffectValue_ScriptParam__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::core.EffectValue.Types.ScriptParam, global::core.EffectValue.Types.ScriptParam.Builder> internal__static_core_EffectValue_ScriptParam__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_core_EffectValue_ScriptFunc__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::core.EffectValue.Types.ScriptFunc, global::core.EffectValue.Types.ScriptFunc.Builder> internal__static_core_EffectValue_ScriptFunc__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_core_Effects__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::core.Effects, global::core.Effects.Builder> internal__static_core_Effects__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_core_Effects_Selector__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::core.Effects.Types.Selector, global::core.Effects.Types.Selector.Builder> internal__static_core_Effects_Selector__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_core_Container__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::core.Container, global::core.Container.Builder> internal__static_core_Container__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_core_Respon__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::core.Respon, global::core.Respon.Builder> internal__static_core_Respon__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_core_NullRequst__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::core.NullRequst, global::core.NullRequst.Builder> internal__static_core_NullRequst__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static System() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          "CgxzeXN0ZW0ucHJvdG8SBGNvcmUiHgoER1VJRBIKCgJsbxgBIAIoBhIKCgJo" + 
          "aRgCIAIoBiImCgRCYXNlEgwKBHR5cGUYASACKAUSEAoIdGVtcGxhdGUYAiAC" + 
          "KAUiXAoIQmFzZUl0ZW0SGAoEYmFzZRgBIAIoCzIKLmNvcmUuQmFzZRIMCgRu" + 
          "YW1lGAIgAigJEhMKC292ZXJsYXBfY3VyGAMgAigFEhMKC292ZXJsYXBfbWF4" + 
          "GAQgAigFIlEKCFBvc2l0aW9uEgkKAXgYASACKAISCQoBeRgCIAIoAhIJCgF6" + 
          "GAMgAigCEgkKAWQYBCACKAISCwoDbWFwGAUgAigFEgwKBGNvcHkYBiACKAUi" + 
          "NgoITW92ZUFibGUSGwoDcG9zGAEgAigLMg4uY29yZS5Qb3NpdGlvbhINCgVz" + 
          "cGVlZBgCIAIoAiIyCgRSZWN0EgkKAXgYASACKAUSCQoBeRgCIAIoBRIJCgF3" + 
          "GAMgAigFEgkKAWgYBCACKAUiHQoFUG9pbnQSCQoBeBgBIAIoBRIJCgF5GAIg" + 
          "AigFIh4KBlBvaW50RhIJCgF4GAEgAigCEgkKAXkYAiACKAIi/gEKCkxpbWl0" + 
          "VmFsdWUSEgoKZmllbGRfbmFtZRgBIAIoCRIfCgJvcBgCIAIoDjITLmNvcmUu" + 
          "TGltaXRWYWx1ZS5PcBIuCgp2YWx1ZV90eXBlGAMgAigOMhouY29yZS5MaW1p" + 
          "dFZhbHVlLlZhbHVlVHlwZRINCgV2YWx1ZRgEIAMoBSJUCgJPcBIQCgxHcmVh" + 
          "dGVyRXF1YWwQABILCgdHcmVhdGVyEAESCQoFRXF1YWwQAhIMCghMZXNzcXVh" + 
          "bBADEggKBExlc3MQBBIMCghOb3RFcXVhbBAFIiYKCVZhbHVlVHlwZRIMCghD" + 
          "b25zdGFudBAAEgsKB1ByZWNlbnQQASJ7CgZMaW1pdHMSEAoIcmVsYXRpb24Y" + 
          "ASACKAkSJwoNaGFuZGxlX2xpbWl0cxgCIAMoCzIQLmNvcmUuTGltaXRWYWx1" + 
          "ZRInCg10YXJnZXRfbGltaXRzGAMgAygLMhAuY29yZS5MaW1pdFZhbHVlEg0K" + 
          "BXN0YW5kGAQgAigFIrADCgtFZmZlY3RWYWx1ZRISCgpmaWVsZF9uYW1lGAEg" + 
          "AigJEiAKAm9wGAIgAigOMhQuY29yZS5FZmZlY3RWYWx1ZS5PcBIkCgR0eXBl" + 
          "GAMgAigOMhYuY29yZS5FZmZlY3RWYWx1ZS5UeXBlEiwKBnNjcmlwdBgEIAEo" + 
          "CzIcLmNvcmUuRWZmZWN0VmFsdWUuU2NyaXB0RnVuYxINCgV2YWx1ZRgFIAMo" + 
          "AhoYCgtTY3JpcHRQYXJhbRIJCgFwGAEgAygCGk0KClNjcmlwdEZ1bmMSEAoI" + 
          "ZnVuY3Rpb24YASACKAkSLQoGcGFyYW1zGAIgAygLMh0uY29yZS5FZmZlY3RW" + 
          "YWx1ZS5TY3JpcHRQYXJhbSJyCgJPcBIHCgNBZGQQABIOCgpQZXJzZW50QWRk" + 
          "EAESEwoPRmllbGRQZXJzZW50QWRkEAISCwoHUmVwbGFjZRADEgoKBlByZWZp" + 
          "eBAEEgsKB1Bvc3RmaXgQBRILCgdBZGRGbGFnEAYSCwoHRGVsRmxhZxAHIisK" + 
          "BFR5cGUSDAoIQ29uc3RhbnQQABIKCgZTY3JpcHQQARIJCgVTdGF0ZRACIt0B" + 
          "CgdFZmZlY3RzEhAKCHJlbGF0aW9uGAEgAigJEiQKCWVmZmVjdG9ycxgCIAMo" + 
          "CzIRLmNvcmUuRWZmZWN0VmFsdWUSKQoJc2VsZWN0b3JzGAMgAygLMhYuY29y" + 
          "ZS5FZmZlY3RzLlNlbGVjdG9yGm8KCFNlbGVjdG9yEikKBHR5cGUYASACKA4y" + 
          "Gy5jb3JlLkVmZmVjdHMuU2VsZWN0b3IuVHlwZRIOCgZwYXJhbXMYAiADKAIi" + 
          "KAoEVHlwZRIJCgVTdGFuZBAAEgkKBVNwYWNlEAESCgoGQXR0cmliEAIiKgoJ" + 
          "Q29udGFpbmVyEh0KCXJlZmVyZW5jZRgBIAMoCzIKLmNvcmUuR1VJRCIYCgZS" + 
          "ZXNwb24SDgoGcmVzdWx0GAEgAigFIgwKCk51bGxSZXF1c3Q=");
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_core_GUID__Descriptor = Descriptor.MessageTypes[0];
        internal__static_core_GUID__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::core.GUID, global::core.GUID.Builder>(internal__static_core_GUID__Descriptor,
                new string[] { "Lo", "Hi", });
        internal__static_core_Base__Descriptor = Descriptor.MessageTypes[1];
        internal__static_core_Base__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::core.Base, global::core.Base.Builder>(internal__static_core_Base__Descriptor,
                new string[] { "Type", "Template", });
        internal__static_core_BaseItem__Descriptor = Descriptor.MessageTypes[2];
        internal__static_core_BaseItem__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::core.BaseItem, global::core.BaseItem.Builder>(internal__static_core_BaseItem__Descriptor,
                new string[] { "Base", "Name", "OverlapCur", "OverlapMax", });
        internal__static_core_Position__Descriptor = Descriptor.MessageTypes[3];
        internal__static_core_Position__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::core.Position, global::core.Position.Builder>(internal__static_core_Position__Descriptor,
                new string[] { "X", "Y", "Z", "D", "Map", "Copy", });
        internal__static_core_MoveAble__Descriptor = Descriptor.MessageTypes[4];
        internal__static_core_MoveAble__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::core.MoveAble, global::core.MoveAble.Builder>(internal__static_core_MoveAble__Descriptor,
                new string[] { "Pos", "Speed", });
        internal__static_core_Rect__Descriptor = Descriptor.MessageTypes[5];
        internal__static_core_Rect__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::core.Rect, global::core.Rect.Builder>(internal__static_core_Rect__Descriptor,
                new string[] { "X", "Y", "W", "H", });
        internal__static_core_Point__Descriptor = Descriptor.MessageTypes[6];
        internal__static_core_Point__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::core.Point, global::core.Point.Builder>(internal__static_core_Point__Descriptor,
                new string[] { "X", "Y", });
        internal__static_core_PointF__Descriptor = Descriptor.MessageTypes[7];
        internal__static_core_PointF__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::core.PointF, global::core.PointF.Builder>(internal__static_core_PointF__Descriptor,
                new string[] { "X", "Y", });
        internal__static_core_LimitValue__Descriptor = Descriptor.MessageTypes[8];
        internal__static_core_LimitValue__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::core.LimitValue, global::core.LimitValue.Builder>(internal__static_core_LimitValue__Descriptor,
                new string[] { "FieldName", "Op", "ValueType", "Value", });
        internal__static_core_Limits__Descriptor = Descriptor.MessageTypes[9];
        internal__static_core_Limits__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::core.Limits, global::core.Limits.Builder>(internal__static_core_Limits__Descriptor,
                new string[] { "Relation", "HandleLimits", "TargetLimits", "Stand", });
        internal__static_core_EffectValue__Descriptor = Descriptor.MessageTypes[10];
        internal__static_core_EffectValue__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::core.EffectValue, global::core.EffectValue.Builder>(internal__static_core_EffectValue__Descriptor,
                new string[] { "FieldName", "Op", "Type", "Script", "Value", });
        internal__static_core_EffectValue_ScriptParam__Descriptor = internal__static_core_EffectValue__Descriptor.NestedTypes[0];
        internal__static_core_EffectValue_ScriptParam__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::core.EffectValue.Types.ScriptParam, global::core.EffectValue.Types.ScriptParam.Builder>(internal__static_core_EffectValue_ScriptParam__Descriptor,
                new string[] { "P", });
        internal__static_core_EffectValue_ScriptFunc__Descriptor = internal__static_core_EffectValue__Descriptor.NestedTypes[1];
        internal__static_core_EffectValue_ScriptFunc__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::core.EffectValue.Types.ScriptFunc, global::core.EffectValue.Types.ScriptFunc.Builder>(internal__static_core_EffectValue_ScriptFunc__Descriptor,
                new string[] { "Function", "Params", });
        internal__static_core_Effects__Descriptor = Descriptor.MessageTypes[11];
        internal__static_core_Effects__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::core.Effects, global::core.Effects.Builder>(internal__static_core_Effects__Descriptor,
                new string[] { "Relation", "Effectors", "Selectors", });
        internal__static_core_Effects_Selector__Descriptor = internal__static_core_Effects__Descriptor.NestedTypes[0];
        internal__static_core_Effects_Selector__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::core.Effects.Types.Selector, global::core.Effects.Types.Selector.Builder>(internal__static_core_Effects_Selector__Descriptor,
                new string[] { "Type", "Params", });
        internal__static_core_Container__Descriptor = Descriptor.MessageTypes[12];
        internal__static_core_Container__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::core.Container, global::core.Container.Builder>(internal__static_core_Container__Descriptor,
                new string[] { "Reference", });
        internal__static_core_Respon__Descriptor = Descriptor.MessageTypes[13];
        internal__static_core_Respon__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::core.Respon, global::core.Respon.Builder>(internal__static_core_Respon__Descriptor,
                new string[] { "Result", });
        internal__static_core_NullRequst__Descriptor = Descriptor.MessageTypes[14];
        internal__static_core_NullRequst__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::core.NullRequst, global::core.NullRequst.Builder>(internal__static_core_NullRequst__Descriptor,
                new string[] { });
        return null;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          }, assigner);
    }
    #endregion
    
  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class GUID : pb::GeneratedMessage<GUID, GUID.Builder> {
    private GUID() { }
    private static readonly GUID defaultInstance = new GUID().MakeReadOnly();
    private static readonly string[] _gUIDFieldNames = new string[] { "hi", "lo" };
    private static readonly uint[] _gUIDFieldTags = new uint[] { 17, 9 };
    public static GUID DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override GUID DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override GUID ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::core.System.internal__static_core_GUID__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<GUID, GUID.Builder> InternalFieldAccessors {
      get { return global::core.System.internal__static_core_GUID__FieldAccessorTable; }
    }
    
    public const int LoFieldNumber = 1;
    private bool hasLo;
    private ulong lo_;
    public bool HasLo {
      get { return hasLo; }
    }
    [global::System.CLSCompliant(false)]
    public ulong Lo {
      get { return lo_; }
    }
    
    public const int HiFieldNumber = 2;
    private bool hasHi;
    private ulong hi_;
    public bool HasHi {
      get { return hasHi; }
    }
    [global::System.CLSCompliant(false)]
    public ulong Hi {
      get { return hi_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasLo) return false;
        if (!hasHi) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _gUIDFieldNames;
      if (hasLo) {
        output.WriteFixed64(1, field_names[1], Lo);
      }
      if (hasHi) {
        output.WriteFixed64(2, field_names[0], Hi);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasLo) {
          size += pb::CodedOutputStream.ComputeFixed64Size(1, Lo);
        }
        if (hasHi) {
          size += pb::CodedOutputStream.ComputeFixed64Size(2, Hi);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static GUID ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GUID ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GUID ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static GUID ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static GUID ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GUID ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static GUID ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static GUID ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static GUID ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static GUID ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private GUID MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(GUID prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<GUID, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(GUID cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private GUID result;
      
      private GUID PrepareBuilder() {
        if (resultIsReadOnly) {
          GUID original = result;
          result = new GUID();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override GUID MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::core.GUID.Descriptor; }
      }
      
      public override GUID DefaultInstanceForType {
        get { return global::core.GUID.DefaultInstance; }
      }
      
      public override GUID BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is GUID) {
          return MergeFrom((GUID) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(GUID other) {
        if (other == global::core.GUID.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasLo) {
          Lo = other.Lo;
        }
        if (other.HasHi) {
          Hi = other.Hi;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_gUIDFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _gUIDFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 9: {
              result.hasLo = input.ReadFixed64(ref result.lo_);
              break;
            }
            case 17: {
              result.hasHi = input.ReadFixed64(ref result.hi_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasLo {
        get { return result.hasLo; }
      }
      [global::System.CLSCompliant(false)]
      public ulong Lo {
        get { return result.Lo; }
        set { SetLo(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetLo(ulong value) {
        PrepareBuilder();
        result.hasLo = true;
        result.lo_ = value;
        return this;
      }
      public Builder ClearLo() {
        PrepareBuilder();
        result.hasLo = false;
        result.lo_ = 0;
        return this;
      }
      
      public bool HasHi {
        get { return result.hasHi; }
      }
      [global::System.CLSCompliant(false)]
      public ulong Hi {
        get { return result.Hi; }
        set { SetHi(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetHi(ulong value) {
        PrepareBuilder();
        result.hasHi = true;
        result.hi_ = value;
        return this;
      }
      public Builder ClearHi() {
        PrepareBuilder();
        result.hasHi = false;
        result.hi_ = 0;
        return this;
      }
    }
    static GUID() {
      object.ReferenceEquals(global::core.System.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Base : pb::GeneratedMessage<Base, Base.Builder> {
    private Base() { }
    private static readonly Base defaultInstance = new Base().MakeReadOnly();
    private static readonly string[] _baseFieldNames = new string[] { "template", "type" };
    private static readonly uint[] _baseFieldTags = new uint[] { 16, 8 };
    public static Base DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Base DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Base ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::core.System.internal__static_core_Base__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Base, Base.Builder> InternalFieldAccessors {
      get { return global::core.System.internal__static_core_Base__FieldAccessorTable; }
    }
    
    public const int TypeFieldNumber = 1;
    private bool hasType;
    private int type_;
    public bool HasType {
      get { return hasType; }
    }
    public int Type {
      get { return type_; }
    }
    
    public const int TemplateFieldNumber = 2;
    private bool hasTemplate;
    private int template_;
    public bool HasTemplate {
      get { return hasTemplate; }
    }
    public int Template {
      get { return template_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasType) return false;
        if (!hasTemplate) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _baseFieldNames;
      if (hasType) {
        output.WriteInt32(1, field_names[1], Type);
      }
      if (hasTemplate) {
        output.WriteInt32(2, field_names[0], Template);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasType) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, Type);
        }
        if (hasTemplate) {
          size += pb::CodedOutputStream.ComputeInt32Size(2, Template);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Base ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Base ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Base ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Base ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Base ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Base ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Base ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Base ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Base ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Base ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Base MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Base prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Base, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Base cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Base result;
      
      private Base PrepareBuilder() {
        if (resultIsReadOnly) {
          Base original = result;
          result = new Base();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Base MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::core.Base.Descriptor; }
      }
      
      public override Base DefaultInstanceForType {
        get { return global::core.Base.DefaultInstance; }
      }
      
      public override Base BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Base) {
          return MergeFrom((Base) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Base other) {
        if (other == global::core.Base.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasType) {
          Type = other.Type;
        }
        if (other.HasTemplate) {
          Template = other.Template;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_baseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _baseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasType = input.ReadInt32(ref result.type_);
              break;
            }
            case 16: {
              result.hasTemplate = input.ReadInt32(ref result.template_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasType {
        get { return result.hasType; }
      }
      public int Type {
        get { return result.Type; }
        set { SetType(value); }
      }
      public Builder SetType(int value) {
        PrepareBuilder();
        result.hasType = true;
        result.type_ = value;
        return this;
      }
      public Builder ClearType() {
        PrepareBuilder();
        result.hasType = false;
        result.type_ = 0;
        return this;
      }
      
      public bool HasTemplate {
        get { return result.hasTemplate; }
      }
      public int Template {
        get { return result.Template; }
        set { SetTemplate(value); }
      }
      public Builder SetTemplate(int value) {
        PrepareBuilder();
        result.hasTemplate = true;
        result.template_ = value;
        return this;
      }
      public Builder ClearTemplate() {
        PrepareBuilder();
        result.hasTemplate = false;
        result.template_ = 0;
        return this;
      }
    }
    static Base() {
      object.ReferenceEquals(global::core.System.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class BaseItem : pb::GeneratedMessage<BaseItem, BaseItem.Builder> {
    private BaseItem() { }
    private static readonly BaseItem defaultInstance = new BaseItem().MakeReadOnly();
    private static readonly string[] _baseItemFieldNames = new string[] { "base", "name", "overlap_cur", "overlap_max" };
    private static readonly uint[] _baseItemFieldTags = new uint[] { 10, 18, 24, 32 };
    public static BaseItem DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override BaseItem DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override BaseItem ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::core.System.internal__static_core_BaseItem__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<BaseItem, BaseItem.Builder> InternalFieldAccessors {
      get { return global::core.System.internal__static_core_BaseItem__FieldAccessorTable; }
    }
    
    public const int BaseFieldNumber = 1;
    private bool hasBase;
    private global::core.Base base_;
    public bool HasBase {
      get { return hasBase; }
    }
    public global::core.Base Base {
      get { return base_ ?? global::core.Base.DefaultInstance; }
    }
    
    public const int NameFieldNumber = 2;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int OverlapCurFieldNumber = 3;
    private bool hasOverlapCur;
    private int overlapCur_;
    public bool HasOverlapCur {
      get { return hasOverlapCur; }
    }
    public int OverlapCur {
      get { return overlapCur_; }
    }
    
    public const int OverlapMaxFieldNumber = 4;
    private bool hasOverlapMax;
    private int overlapMax_;
    public bool HasOverlapMax {
      get { return hasOverlapMax; }
    }
    public int OverlapMax {
      get { return overlapMax_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasBase) return false;
        if (!hasName) return false;
        if (!hasOverlapCur) return false;
        if (!hasOverlapMax) return false;
        if (!Base.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _baseItemFieldNames;
      if (hasBase) {
        output.WriteMessage(1, field_names[0], Base);
      }
      if (hasName) {
        output.WriteString(2, field_names[1], Name);
      }
      if (hasOverlapCur) {
        output.WriteInt32(3, field_names[2], OverlapCur);
      }
      if (hasOverlapMax) {
        output.WriteInt32(4, field_names[3], OverlapMax);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasBase) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Base);
        }
        if (hasName) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Name);
        }
        if (hasOverlapCur) {
          size += pb::CodedOutputStream.ComputeInt32Size(3, OverlapCur);
        }
        if (hasOverlapMax) {
          size += pb::CodedOutputStream.ComputeInt32Size(4, OverlapMax);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static BaseItem ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static BaseItem ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static BaseItem ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static BaseItem ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static BaseItem ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static BaseItem ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static BaseItem ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static BaseItem ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static BaseItem ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static BaseItem ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private BaseItem MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(BaseItem prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<BaseItem, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(BaseItem cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private BaseItem result;
      
      private BaseItem PrepareBuilder() {
        if (resultIsReadOnly) {
          BaseItem original = result;
          result = new BaseItem();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override BaseItem MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::core.BaseItem.Descriptor; }
      }
      
      public override BaseItem DefaultInstanceForType {
        get { return global::core.BaseItem.DefaultInstance; }
      }
      
      public override BaseItem BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is BaseItem) {
          return MergeFrom((BaseItem) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(BaseItem other) {
        if (other == global::core.BaseItem.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasBase) {
          MergeBase(other.Base);
        }
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasOverlapCur) {
          OverlapCur = other.OverlapCur;
        }
        if (other.HasOverlapMax) {
          OverlapMax = other.OverlapMax;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_baseItemFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _baseItemFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::core.Base.Builder subBuilder = global::core.Base.CreateBuilder();
              if (result.hasBase) {
                subBuilder.MergeFrom(Base);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Base = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 24: {
              result.hasOverlapCur = input.ReadInt32(ref result.overlapCur_);
              break;
            }
            case 32: {
              result.hasOverlapMax = input.ReadInt32(ref result.overlapMax_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasBase {
       get { return result.hasBase; }
      }
      public global::core.Base Base {
        get { return result.Base; }
        set { SetBase(value); }
      }
      public Builder SetBase(global::core.Base value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasBase = true;
        result.base_ = value;
        return this;
      }
      public Builder SetBase(global::core.Base.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasBase = true;
        result.base_ = builderForValue.Build();
        return this;
      }
      public Builder MergeBase(global::core.Base value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasBase &&
            result.base_ != global::core.Base.DefaultInstance) {
            result.base_ = global::core.Base.CreateBuilder(result.base_).MergeFrom(value).BuildPartial();
        } else {
          result.base_ = value;
        }
        result.hasBase = true;
        return this;
      }
      public Builder ClearBase() {
        PrepareBuilder();
        result.hasBase = false;
        result.base_ = null;
        return this;
      }
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasOverlapCur {
        get { return result.hasOverlapCur; }
      }
      public int OverlapCur {
        get { return result.OverlapCur; }
        set { SetOverlapCur(value); }
      }
      public Builder SetOverlapCur(int value) {
        PrepareBuilder();
        result.hasOverlapCur = true;
        result.overlapCur_ = value;
        return this;
      }
      public Builder ClearOverlapCur() {
        PrepareBuilder();
        result.hasOverlapCur = false;
        result.overlapCur_ = 0;
        return this;
      }
      
      public bool HasOverlapMax {
        get { return result.hasOverlapMax; }
      }
      public int OverlapMax {
        get { return result.OverlapMax; }
        set { SetOverlapMax(value); }
      }
      public Builder SetOverlapMax(int value) {
        PrepareBuilder();
        result.hasOverlapMax = true;
        result.overlapMax_ = value;
        return this;
      }
      public Builder ClearOverlapMax() {
        PrepareBuilder();
        result.hasOverlapMax = false;
        result.overlapMax_ = 0;
        return this;
      }
    }
    static BaseItem() {
      object.ReferenceEquals(global::core.System.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Position : pb::GeneratedMessage<Position, Position.Builder> {
    private Position() { }
    private static readonly Position defaultInstance = new Position().MakeReadOnly();
    private static readonly string[] _positionFieldNames = new string[] { "copy", "d", "map", "x", "y", "z" };
    private static readonly uint[] _positionFieldTags = new uint[] { 48, 37, 40, 13, 21, 29 };
    public static Position DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Position DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Position ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::core.System.internal__static_core_Position__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Position, Position.Builder> InternalFieldAccessors {
      get { return global::core.System.internal__static_core_Position__FieldAccessorTable; }
    }
    
    public const int XFieldNumber = 1;
    private bool hasX;
    private float x_;
    public bool HasX {
      get { return hasX; }
    }
    public float X {
      get { return x_; }
    }
    
    public const int YFieldNumber = 2;
    private bool hasY;
    private float y_;
    public bool HasY {
      get { return hasY; }
    }
    public float Y {
      get { return y_; }
    }
    
    public const int ZFieldNumber = 3;
    private bool hasZ;
    private float z_;
    public bool HasZ {
      get { return hasZ; }
    }
    public float Z {
      get { return z_; }
    }
    
    public const int DFieldNumber = 4;
    private bool hasD;
    private float d_;
    public bool HasD {
      get { return hasD; }
    }
    public float D {
      get { return d_; }
    }
    
    public const int MapFieldNumber = 5;
    private bool hasMap;
    private int map_;
    public bool HasMap {
      get { return hasMap; }
    }
    public int Map {
      get { return map_; }
    }
    
    public const int CopyFieldNumber = 6;
    private bool hasCopy;
    private int copy_;
    public bool HasCopy {
      get { return hasCopy; }
    }
    public int Copy {
      get { return copy_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasX) return false;
        if (!hasY) return false;
        if (!hasZ) return false;
        if (!hasD) return false;
        if (!hasMap) return false;
        if (!hasCopy) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _positionFieldNames;
      if (hasX) {
        output.WriteFloat(1, field_names[3], X);
      }
      if (hasY) {
        output.WriteFloat(2, field_names[4], Y);
      }
      if (hasZ) {
        output.WriteFloat(3, field_names[5], Z);
      }
      if (hasD) {
        output.WriteFloat(4, field_names[1], D);
      }
      if (hasMap) {
        output.WriteInt32(5, field_names[2], Map);
      }
      if (hasCopy) {
        output.WriteInt32(6, field_names[0], Copy);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasX) {
          size += pb::CodedOutputStream.ComputeFloatSize(1, X);
        }
        if (hasY) {
          size += pb::CodedOutputStream.ComputeFloatSize(2, Y);
        }
        if (hasZ) {
          size += pb::CodedOutputStream.ComputeFloatSize(3, Z);
        }
        if (hasD) {
          size += pb::CodedOutputStream.ComputeFloatSize(4, D);
        }
        if (hasMap) {
          size += pb::CodedOutputStream.ComputeInt32Size(5, Map);
        }
        if (hasCopy) {
          size += pb::CodedOutputStream.ComputeInt32Size(6, Copy);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Position ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Position ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Position ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Position ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Position ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Position ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Position ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Position ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Position ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Position ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Position MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Position prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Position, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Position cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Position result;
      
      private Position PrepareBuilder() {
        if (resultIsReadOnly) {
          Position original = result;
          result = new Position();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Position MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::core.Position.Descriptor; }
      }
      
      public override Position DefaultInstanceForType {
        get { return global::core.Position.DefaultInstance; }
      }
      
      public override Position BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Position) {
          return MergeFrom((Position) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Position other) {
        if (other == global::core.Position.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasX) {
          X = other.X;
        }
        if (other.HasY) {
          Y = other.Y;
        }
        if (other.HasZ) {
          Z = other.Z;
        }
        if (other.HasD) {
          D = other.D;
        }
        if (other.HasMap) {
          Map = other.Map;
        }
        if (other.HasCopy) {
          Copy = other.Copy;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_positionFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _positionFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 13: {
              result.hasX = input.ReadFloat(ref result.x_);
              break;
            }
            case 21: {
              result.hasY = input.ReadFloat(ref result.y_);
              break;
            }
            case 29: {
              result.hasZ = input.ReadFloat(ref result.z_);
              break;
            }
            case 37: {
              result.hasD = input.ReadFloat(ref result.d_);
              break;
            }
            case 40: {
              result.hasMap = input.ReadInt32(ref result.map_);
              break;
            }
            case 48: {
              result.hasCopy = input.ReadInt32(ref result.copy_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasX {
        get { return result.hasX; }
      }
      public float X {
        get { return result.X; }
        set { SetX(value); }
      }
      public Builder SetX(float value) {
        PrepareBuilder();
        result.hasX = true;
        result.x_ = value;
        return this;
      }
      public Builder ClearX() {
        PrepareBuilder();
        result.hasX = false;
        result.x_ = 0F;
        return this;
      }
      
      public bool HasY {
        get { return result.hasY; }
      }
      public float Y {
        get { return result.Y; }
        set { SetY(value); }
      }
      public Builder SetY(float value) {
        PrepareBuilder();
        result.hasY = true;
        result.y_ = value;
        return this;
      }
      public Builder ClearY() {
        PrepareBuilder();
        result.hasY = false;
        result.y_ = 0F;
        return this;
      }
      
      public bool HasZ {
        get { return result.hasZ; }
      }
      public float Z {
        get { return result.Z; }
        set { SetZ(value); }
      }
      public Builder SetZ(float value) {
        PrepareBuilder();
        result.hasZ = true;
        result.z_ = value;
        return this;
      }
      public Builder ClearZ() {
        PrepareBuilder();
        result.hasZ = false;
        result.z_ = 0F;
        return this;
      }
      
      public bool HasD {
        get { return result.hasD; }
      }
      public float D {
        get { return result.D; }
        set { SetD(value); }
      }
      public Builder SetD(float value) {
        PrepareBuilder();
        result.hasD = true;
        result.d_ = value;
        return this;
      }
      public Builder ClearD() {
        PrepareBuilder();
        result.hasD = false;
        result.d_ = 0F;
        return this;
      }
      
      public bool HasMap {
        get { return result.hasMap; }
      }
      public int Map {
        get { return result.Map; }
        set { SetMap(value); }
      }
      public Builder SetMap(int value) {
        PrepareBuilder();
        result.hasMap = true;
        result.map_ = value;
        return this;
      }
      public Builder ClearMap() {
        PrepareBuilder();
        result.hasMap = false;
        result.map_ = 0;
        return this;
      }
      
      public bool HasCopy {
        get { return result.hasCopy; }
      }
      public int Copy {
        get { return result.Copy; }
        set { SetCopy(value); }
      }
      public Builder SetCopy(int value) {
        PrepareBuilder();
        result.hasCopy = true;
        result.copy_ = value;
        return this;
      }
      public Builder ClearCopy() {
        PrepareBuilder();
        result.hasCopy = false;
        result.copy_ = 0;
        return this;
      }
    }
    static Position() {
      object.ReferenceEquals(global::core.System.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class MoveAble : pb::GeneratedMessage<MoveAble, MoveAble.Builder> {
    private MoveAble() { }
    private static readonly MoveAble defaultInstance = new MoveAble().MakeReadOnly();
    private static readonly string[] _moveAbleFieldNames = new string[] { "pos", "speed" };
    private static readonly uint[] _moveAbleFieldTags = new uint[] { 10, 21 };
    public static MoveAble DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override MoveAble DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override MoveAble ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::core.System.internal__static_core_MoveAble__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<MoveAble, MoveAble.Builder> InternalFieldAccessors {
      get { return global::core.System.internal__static_core_MoveAble__FieldAccessorTable; }
    }
    
    public const int PosFieldNumber = 1;
    private bool hasPos;
    private global::core.Position pos_;
    public bool HasPos {
      get { return hasPos; }
    }
    public global::core.Position Pos {
      get { return pos_ ?? global::core.Position.DefaultInstance; }
    }
    
    public const int SpeedFieldNumber = 2;
    private bool hasSpeed;
    private float speed_;
    public bool HasSpeed {
      get { return hasSpeed; }
    }
    public float Speed {
      get { return speed_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasPos) return false;
        if (!hasSpeed) return false;
        if (!Pos.IsInitialized) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _moveAbleFieldNames;
      if (hasPos) {
        output.WriteMessage(1, field_names[0], Pos);
      }
      if (hasSpeed) {
        output.WriteFloat(2, field_names[1], Speed);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasPos) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, Pos);
        }
        if (hasSpeed) {
          size += pb::CodedOutputStream.ComputeFloatSize(2, Speed);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static MoveAble ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MoveAble ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MoveAble ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static MoveAble ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static MoveAble ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MoveAble ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static MoveAble ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static MoveAble ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static MoveAble ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static MoveAble ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private MoveAble MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(MoveAble prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<MoveAble, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(MoveAble cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private MoveAble result;
      
      private MoveAble PrepareBuilder() {
        if (resultIsReadOnly) {
          MoveAble original = result;
          result = new MoveAble();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override MoveAble MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::core.MoveAble.Descriptor; }
      }
      
      public override MoveAble DefaultInstanceForType {
        get { return global::core.MoveAble.DefaultInstance; }
      }
      
      public override MoveAble BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is MoveAble) {
          return MergeFrom((MoveAble) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(MoveAble other) {
        if (other == global::core.MoveAble.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasPos) {
          MergePos(other.Pos);
        }
        if (other.HasSpeed) {
          Speed = other.Speed;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_moveAbleFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _moveAbleFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::core.Position.Builder subBuilder = global::core.Position.CreateBuilder();
              if (result.hasPos) {
                subBuilder.MergeFrom(Pos);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Pos = subBuilder.BuildPartial();
              break;
            }
            case 21: {
              result.hasSpeed = input.ReadFloat(ref result.speed_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasPos {
       get { return result.hasPos; }
      }
      public global::core.Position Pos {
        get { return result.Pos; }
        set { SetPos(value); }
      }
      public Builder SetPos(global::core.Position value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPos = true;
        result.pos_ = value;
        return this;
      }
      public Builder SetPos(global::core.Position.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasPos = true;
        result.pos_ = builderForValue.Build();
        return this;
      }
      public Builder MergePos(global::core.Position value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasPos &&
            result.pos_ != global::core.Position.DefaultInstance) {
            result.pos_ = global::core.Position.CreateBuilder(result.pos_).MergeFrom(value).BuildPartial();
        } else {
          result.pos_ = value;
        }
        result.hasPos = true;
        return this;
      }
      public Builder ClearPos() {
        PrepareBuilder();
        result.hasPos = false;
        result.pos_ = null;
        return this;
      }
      
      public bool HasSpeed {
        get { return result.hasSpeed; }
      }
      public float Speed {
        get { return result.Speed; }
        set { SetSpeed(value); }
      }
      public Builder SetSpeed(float value) {
        PrepareBuilder();
        result.hasSpeed = true;
        result.speed_ = value;
        return this;
      }
      public Builder ClearSpeed() {
        PrepareBuilder();
        result.hasSpeed = false;
        result.speed_ = 0F;
        return this;
      }
    }
    static MoveAble() {
      object.ReferenceEquals(global::core.System.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Rect : pb::GeneratedMessage<Rect, Rect.Builder> {
    private Rect() { }
    private static readonly Rect defaultInstance = new Rect().MakeReadOnly();
    private static readonly string[] _rectFieldNames = new string[] { "h", "w", "x", "y" };
    private static readonly uint[] _rectFieldTags = new uint[] { 32, 24, 8, 16 };
    public static Rect DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Rect DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Rect ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::core.System.internal__static_core_Rect__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Rect, Rect.Builder> InternalFieldAccessors {
      get { return global::core.System.internal__static_core_Rect__FieldAccessorTable; }
    }
    
    public const int XFieldNumber = 1;
    private bool hasX;
    private int x_;
    public bool HasX {
      get { return hasX; }
    }
    public int X {
      get { return x_; }
    }
    
    public const int YFieldNumber = 2;
    private bool hasY;
    private int y_;
    public bool HasY {
      get { return hasY; }
    }
    public int Y {
      get { return y_; }
    }
    
    public const int WFieldNumber = 3;
    private bool hasW;
    private int w_;
    public bool HasW {
      get { return hasW; }
    }
    public int W {
      get { return w_; }
    }
    
    public const int HFieldNumber = 4;
    private bool hasH;
    private int h_;
    public bool HasH {
      get { return hasH; }
    }
    public int H {
      get { return h_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasX) return false;
        if (!hasY) return false;
        if (!hasW) return false;
        if (!hasH) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _rectFieldNames;
      if (hasX) {
        output.WriteInt32(1, field_names[2], X);
      }
      if (hasY) {
        output.WriteInt32(2, field_names[3], Y);
      }
      if (hasW) {
        output.WriteInt32(3, field_names[1], W);
      }
      if (hasH) {
        output.WriteInt32(4, field_names[0], H);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasX) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, X);
        }
        if (hasY) {
          size += pb::CodedOutputStream.ComputeInt32Size(2, Y);
        }
        if (hasW) {
          size += pb::CodedOutputStream.ComputeInt32Size(3, W);
        }
        if (hasH) {
          size += pb::CodedOutputStream.ComputeInt32Size(4, H);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Rect ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Rect ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Rect ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Rect ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Rect ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Rect ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Rect ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Rect ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Rect ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Rect ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Rect MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Rect prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Rect, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Rect cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Rect result;
      
      private Rect PrepareBuilder() {
        if (resultIsReadOnly) {
          Rect original = result;
          result = new Rect();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Rect MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::core.Rect.Descriptor; }
      }
      
      public override Rect DefaultInstanceForType {
        get { return global::core.Rect.DefaultInstance; }
      }
      
      public override Rect BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Rect) {
          return MergeFrom((Rect) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Rect other) {
        if (other == global::core.Rect.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasX) {
          X = other.X;
        }
        if (other.HasY) {
          Y = other.Y;
        }
        if (other.HasW) {
          W = other.W;
        }
        if (other.HasH) {
          H = other.H;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_rectFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _rectFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasX = input.ReadInt32(ref result.x_);
              break;
            }
            case 16: {
              result.hasY = input.ReadInt32(ref result.y_);
              break;
            }
            case 24: {
              result.hasW = input.ReadInt32(ref result.w_);
              break;
            }
            case 32: {
              result.hasH = input.ReadInt32(ref result.h_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasX {
        get { return result.hasX; }
      }
      public int X {
        get { return result.X; }
        set { SetX(value); }
      }
      public Builder SetX(int value) {
        PrepareBuilder();
        result.hasX = true;
        result.x_ = value;
        return this;
      }
      public Builder ClearX() {
        PrepareBuilder();
        result.hasX = false;
        result.x_ = 0;
        return this;
      }
      
      public bool HasY {
        get { return result.hasY; }
      }
      public int Y {
        get { return result.Y; }
        set { SetY(value); }
      }
      public Builder SetY(int value) {
        PrepareBuilder();
        result.hasY = true;
        result.y_ = value;
        return this;
      }
      public Builder ClearY() {
        PrepareBuilder();
        result.hasY = false;
        result.y_ = 0;
        return this;
      }
      
      public bool HasW {
        get { return result.hasW; }
      }
      public int W {
        get { return result.W; }
        set { SetW(value); }
      }
      public Builder SetW(int value) {
        PrepareBuilder();
        result.hasW = true;
        result.w_ = value;
        return this;
      }
      public Builder ClearW() {
        PrepareBuilder();
        result.hasW = false;
        result.w_ = 0;
        return this;
      }
      
      public bool HasH {
        get { return result.hasH; }
      }
      public int H {
        get { return result.H; }
        set { SetH(value); }
      }
      public Builder SetH(int value) {
        PrepareBuilder();
        result.hasH = true;
        result.h_ = value;
        return this;
      }
      public Builder ClearH() {
        PrepareBuilder();
        result.hasH = false;
        result.h_ = 0;
        return this;
      }
    }
    static Rect() {
      object.ReferenceEquals(global::core.System.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Point : pb::GeneratedMessage<Point, Point.Builder> {
    private Point() { }
    private static readonly Point defaultInstance = new Point().MakeReadOnly();
    private static readonly string[] _pointFieldNames = new string[] { "x", "y" };
    private static readonly uint[] _pointFieldTags = new uint[] { 8, 16 };
    public static Point DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Point DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Point ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::core.System.internal__static_core_Point__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Point, Point.Builder> InternalFieldAccessors {
      get { return global::core.System.internal__static_core_Point__FieldAccessorTable; }
    }
    
    public const int XFieldNumber = 1;
    private bool hasX;
    private int x_;
    public bool HasX {
      get { return hasX; }
    }
    public int X {
      get { return x_; }
    }
    
    public const int YFieldNumber = 2;
    private bool hasY;
    private int y_;
    public bool HasY {
      get { return hasY; }
    }
    public int Y {
      get { return y_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasX) return false;
        if (!hasY) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _pointFieldNames;
      if (hasX) {
        output.WriteInt32(1, field_names[0], X);
      }
      if (hasY) {
        output.WriteInt32(2, field_names[1], Y);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasX) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, X);
        }
        if (hasY) {
          size += pb::CodedOutputStream.ComputeInt32Size(2, Y);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Point ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Point ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Point ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Point ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Point ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Point ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Point ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Point ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Point ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Point ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Point MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Point prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Point, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Point cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Point result;
      
      private Point PrepareBuilder() {
        if (resultIsReadOnly) {
          Point original = result;
          result = new Point();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Point MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::core.Point.Descriptor; }
      }
      
      public override Point DefaultInstanceForType {
        get { return global::core.Point.DefaultInstance; }
      }
      
      public override Point BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Point) {
          return MergeFrom((Point) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Point other) {
        if (other == global::core.Point.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasX) {
          X = other.X;
        }
        if (other.HasY) {
          Y = other.Y;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_pointFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _pointFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasX = input.ReadInt32(ref result.x_);
              break;
            }
            case 16: {
              result.hasY = input.ReadInt32(ref result.y_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasX {
        get { return result.hasX; }
      }
      public int X {
        get { return result.X; }
        set { SetX(value); }
      }
      public Builder SetX(int value) {
        PrepareBuilder();
        result.hasX = true;
        result.x_ = value;
        return this;
      }
      public Builder ClearX() {
        PrepareBuilder();
        result.hasX = false;
        result.x_ = 0;
        return this;
      }
      
      public bool HasY {
        get { return result.hasY; }
      }
      public int Y {
        get { return result.Y; }
        set { SetY(value); }
      }
      public Builder SetY(int value) {
        PrepareBuilder();
        result.hasY = true;
        result.y_ = value;
        return this;
      }
      public Builder ClearY() {
        PrepareBuilder();
        result.hasY = false;
        result.y_ = 0;
        return this;
      }
    }
    static Point() {
      object.ReferenceEquals(global::core.System.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class PointF : pb::GeneratedMessage<PointF, PointF.Builder> {
    private PointF() { }
    private static readonly PointF defaultInstance = new PointF().MakeReadOnly();
    private static readonly string[] _pointFFieldNames = new string[] { "x", "y" };
    private static readonly uint[] _pointFFieldTags = new uint[] { 13, 21 };
    public static PointF DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override PointF DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override PointF ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::core.System.internal__static_core_PointF__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<PointF, PointF.Builder> InternalFieldAccessors {
      get { return global::core.System.internal__static_core_PointF__FieldAccessorTable; }
    }
    
    public const int XFieldNumber = 1;
    private bool hasX;
    private float x_;
    public bool HasX {
      get { return hasX; }
    }
    public float X {
      get { return x_; }
    }
    
    public const int YFieldNumber = 2;
    private bool hasY;
    private float y_;
    public bool HasY {
      get { return hasY; }
    }
    public float Y {
      get { return y_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasX) return false;
        if (!hasY) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _pointFFieldNames;
      if (hasX) {
        output.WriteFloat(1, field_names[0], X);
      }
      if (hasY) {
        output.WriteFloat(2, field_names[1], Y);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasX) {
          size += pb::CodedOutputStream.ComputeFloatSize(1, X);
        }
        if (hasY) {
          size += pb::CodedOutputStream.ComputeFloatSize(2, Y);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static PointF ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PointF ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PointF ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static PointF ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static PointF ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PointF ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static PointF ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static PointF ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static PointF ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static PointF ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private PointF MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(PointF prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<PointF, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(PointF cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private PointF result;
      
      private PointF PrepareBuilder() {
        if (resultIsReadOnly) {
          PointF original = result;
          result = new PointF();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override PointF MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::core.PointF.Descriptor; }
      }
      
      public override PointF DefaultInstanceForType {
        get { return global::core.PointF.DefaultInstance; }
      }
      
      public override PointF BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is PointF) {
          return MergeFrom((PointF) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(PointF other) {
        if (other == global::core.PointF.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasX) {
          X = other.X;
        }
        if (other.HasY) {
          Y = other.Y;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_pointFFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _pointFFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 13: {
              result.hasX = input.ReadFloat(ref result.x_);
              break;
            }
            case 21: {
              result.hasY = input.ReadFloat(ref result.y_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasX {
        get { return result.hasX; }
      }
      public float X {
        get { return result.X; }
        set { SetX(value); }
      }
      public Builder SetX(float value) {
        PrepareBuilder();
        result.hasX = true;
        result.x_ = value;
        return this;
      }
      public Builder ClearX() {
        PrepareBuilder();
        result.hasX = false;
        result.x_ = 0F;
        return this;
      }
      
      public bool HasY {
        get { return result.hasY; }
      }
      public float Y {
        get { return result.Y; }
        set { SetY(value); }
      }
      public Builder SetY(float value) {
        PrepareBuilder();
        result.hasY = true;
        result.y_ = value;
        return this;
      }
      public Builder ClearY() {
        PrepareBuilder();
        result.hasY = false;
        result.y_ = 0F;
        return this;
      }
    }
    static PointF() {
      object.ReferenceEquals(global::core.System.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class LimitValue : pb::GeneratedMessage<LimitValue, LimitValue.Builder> {
    private LimitValue() { }
    private static readonly LimitValue defaultInstance = new LimitValue().MakeReadOnly();
    private static readonly string[] _limitValueFieldNames = new string[] { "field_name", "op", "value", "value_type" };
    private static readonly uint[] _limitValueFieldTags = new uint[] { 10, 16, 32, 24 };
    public static LimitValue DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override LimitValue DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override LimitValue ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::core.System.internal__static_core_LimitValue__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<LimitValue, LimitValue.Builder> InternalFieldAccessors {
      get { return global::core.System.internal__static_core_LimitValue__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public static class Types {
      [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
      [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
      public enum Op {
        GreaterEqual = 0,
        Greater = 1,
        Equal = 2,
        Lessqual = 3,
        Less = 4,
        NotEqual = 5,
      }
      
      [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
      [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
      public enum ValueType {
        Constant = 0,
        Precent = 1,
      }
      
    }
    #endregion
    
    public const int FieldNameFieldNumber = 1;
    private bool hasFieldName;
    private string fieldName_ = "";
    public bool HasFieldName {
      get { return hasFieldName; }
    }
    public string FieldName {
      get { return fieldName_; }
    }
    
    public const int OpFieldNumber = 2;
    private bool hasOp;
    private global::core.LimitValue.Types.Op op_ = global::core.LimitValue.Types.Op.GreaterEqual;
    public bool HasOp {
      get { return hasOp; }
    }
    public global::core.LimitValue.Types.Op Op {
      get { return op_; }
    }
    
    public const int ValueTypeFieldNumber = 3;
    private bool hasValueType;
    private global::core.LimitValue.Types.ValueType valueType_ = global::core.LimitValue.Types.ValueType.Constant;
    public bool HasValueType {
      get { return hasValueType; }
    }
    public global::core.LimitValue.Types.ValueType ValueType {
      get { return valueType_; }
    }
    
    public const int ValueFieldNumber = 4;
    private pbc::PopsicleList<int> value_ = new pbc::PopsicleList<int>();
    public scg::IList<int> ValueList {
      get { return pbc::Lists.AsReadOnly(value_); }
    }
    public int ValueCount {
      get { return value_.Count; }
    }
    public int GetValue(int index) {
      return value_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasFieldName) return false;
        if (!hasOp) return false;
        if (!hasValueType) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _limitValueFieldNames;
      if (hasFieldName) {
        output.WriteString(1, field_names[0], FieldName);
      }
      if (hasOp) {
        output.WriteEnum(2, field_names[1], (int) Op, Op);
      }
      if (hasValueType) {
        output.WriteEnum(3, field_names[3], (int) ValueType, ValueType);
      }
      if (value_.Count > 0) {
        output.WriteInt32Array(4, field_names[2], value_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasFieldName) {
          size += pb::CodedOutputStream.ComputeStringSize(1, FieldName);
        }
        if (hasOp) {
          size += pb::CodedOutputStream.ComputeEnumSize(2, (int) Op);
        }
        if (hasValueType) {
          size += pb::CodedOutputStream.ComputeEnumSize(3, (int) ValueType);
        }
        {
          int dataSize = 0;
          foreach (int element in ValueList) {
            dataSize += pb::CodedOutputStream.ComputeInt32SizeNoTag(element);
          }
          size += dataSize;
          size += 1 * value_.Count;
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static LimitValue ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static LimitValue ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static LimitValue ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static LimitValue ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static LimitValue ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static LimitValue ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static LimitValue ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static LimitValue ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static LimitValue ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static LimitValue ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private LimitValue MakeReadOnly() {
      value_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(LimitValue prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<LimitValue, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(LimitValue cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private LimitValue result;
      
      private LimitValue PrepareBuilder() {
        if (resultIsReadOnly) {
          LimitValue original = result;
          result = new LimitValue();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override LimitValue MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::core.LimitValue.Descriptor; }
      }
      
      public override LimitValue DefaultInstanceForType {
        get { return global::core.LimitValue.DefaultInstance; }
      }
      
      public override LimitValue BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is LimitValue) {
          return MergeFrom((LimitValue) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(LimitValue other) {
        if (other == global::core.LimitValue.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasFieldName) {
          FieldName = other.FieldName;
        }
        if (other.HasOp) {
          Op = other.Op;
        }
        if (other.HasValueType) {
          ValueType = other.ValueType;
        }
        if (other.value_.Count != 0) {
          result.value_.Add(other.value_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_limitValueFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _limitValueFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasFieldName = input.ReadString(ref result.fieldName_);
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.op_, out unknown)) {
                result.hasOp = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
            case 24: {
              object unknown;
              if(input.ReadEnum(ref result.valueType_, out unknown)) {
                result.hasValueType = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(3, (ulong)(int)unknown);
              }
              break;
            }
            case 34:
            case 32: {
              input.ReadInt32Array(tag, field_name, result.value_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasFieldName {
        get { return result.hasFieldName; }
      }
      public string FieldName {
        get { return result.FieldName; }
        set { SetFieldName(value); }
      }
      public Builder SetFieldName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasFieldName = true;
        result.fieldName_ = value;
        return this;
      }
      public Builder ClearFieldName() {
        PrepareBuilder();
        result.hasFieldName = false;
        result.fieldName_ = "";
        return this;
      }
      
      public bool HasOp {
       get { return result.hasOp; }
      }
      public global::core.LimitValue.Types.Op Op {
        get { return result.Op; }
        set { SetOp(value); }
      }
      public Builder SetOp(global::core.LimitValue.Types.Op value) {
        PrepareBuilder();
        result.hasOp = true;
        result.op_ = value;
        return this;
      }
      public Builder ClearOp() {
        PrepareBuilder();
        result.hasOp = false;
        result.op_ = global::core.LimitValue.Types.Op.GreaterEqual;
        return this;
      }
      
      public bool HasValueType {
       get { return result.hasValueType; }
      }
      public global::core.LimitValue.Types.ValueType ValueType {
        get { return result.ValueType; }
        set { SetValueType(value); }
      }
      public Builder SetValueType(global::core.LimitValue.Types.ValueType value) {
        PrepareBuilder();
        result.hasValueType = true;
        result.valueType_ = value;
        return this;
      }
      public Builder ClearValueType() {
        PrepareBuilder();
        result.hasValueType = false;
        result.valueType_ = global::core.LimitValue.Types.ValueType.Constant;
        return this;
      }
      
      public pbc::IPopsicleList<int> ValueList {
        get { return PrepareBuilder().value_; }
      }
      public int ValueCount {
        get { return result.ValueCount; }
      }
      public int GetValue(int index) {
        return result.GetValue(index);
      }
      public Builder SetValue(int index, int value) {
        PrepareBuilder();
        result.value_[index] = value;
        return this;
      }
      public Builder AddValue(int value) {
        PrepareBuilder();
        result.value_.Add(value);
        return this;
      }
      public Builder AddRangeValue(scg::IEnumerable<int> values) {
        PrepareBuilder();
        result.value_.Add(values);
        return this;
      }
      public Builder ClearValue() {
        PrepareBuilder();
        result.value_.Clear();
        return this;
      }
    }
    static LimitValue() {
      object.ReferenceEquals(global::core.System.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Limits : pb::GeneratedMessage<Limits, Limits.Builder> {
    private Limits() { }
    private static readonly Limits defaultInstance = new Limits().MakeReadOnly();
    private static readonly string[] _limitsFieldNames = new string[] { "handle_limits", "relation", "stand", "target_limits" };
    private static readonly uint[] _limitsFieldTags = new uint[] { 18, 10, 32, 26 };
    public static Limits DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Limits DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Limits ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::core.System.internal__static_core_Limits__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Limits, Limits.Builder> InternalFieldAccessors {
      get { return global::core.System.internal__static_core_Limits__FieldAccessorTable; }
    }
    
    public const int RelationFieldNumber = 1;
    private bool hasRelation;
    private string relation_ = "";
    public bool HasRelation {
      get { return hasRelation; }
    }
    public string Relation {
      get { return relation_; }
    }
    
    public const int HandleLimitsFieldNumber = 2;
    private pbc::PopsicleList<global::core.LimitValue> handleLimits_ = new pbc::PopsicleList<global::core.LimitValue>();
    public scg::IList<global::core.LimitValue> HandleLimitsList {
      get { return handleLimits_; }
    }
    public int HandleLimitsCount {
      get { return handleLimits_.Count; }
    }
    public global::core.LimitValue GetHandleLimits(int index) {
      return handleLimits_[index];
    }
    
    public const int TargetLimitsFieldNumber = 3;
    private pbc::PopsicleList<global::core.LimitValue> targetLimits_ = new pbc::PopsicleList<global::core.LimitValue>();
    public scg::IList<global::core.LimitValue> TargetLimitsList {
      get { return targetLimits_; }
    }
    public int TargetLimitsCount {
      get { return targetLimits_.Count; }
    }
    public global::core.LimitValue GetTargetLimits(int index) {
      return targetLimits_[index];
    }
    
    public const int StandFieldNumber = 4;
    private bool hasStand;
    private int stand_;
    public bool HasStand {
      get { return hasStand; }
    }
    public int Stand {
      get { return stand_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasRelation) return false;
        if (!hasStand) return false;
        foreach (global::core.LimitValue element in HandleLimitsList) {
          if (!element.IsInitialized) return false;
        }
        foreach (global::core.LimitValue element in TargetLimitsList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _limitsFieldNames;
      if (hasRelation) {
        output.WriteString(1, field_names[1], Relation);
      }
      if (handleLimits_.Count > 0) {
        output.WriteMessageArray(2, field_names[0], handleLimits_);
      }
      if (targetLimits_.Count > 0) {
        output.WriteMessageArray(3, field_names[3], targetLimits_);
      }
      if (hasStand) {
        output.WriteInt32(4, field_names[2], Stand);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasRelation) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Relation);
        }
        foreach (global::core.LimitValue element in HandleLimitsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, element);
        }
        foreach (global::core.LimitValue element in TargetLimitsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, element);
        }
        if (hasStand) {
          size += pb::CodedOutputStream.ComputeInt32Size(4, Stand);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Limits ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Limits ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Limits ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Limits ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Limits ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Limits ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Limits ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Limits ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Limits ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Limits ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Limits MakeReadOnly() {
      handleLimits_.MakeReadOnly();
      targetLimits_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Limits prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Limits, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Limits cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Limits result;
      
      private Limits PrepareBuilder() {
        if (resultIsReadOnly) {
          Limits original = result;
          result = new Limits();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Limits MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::core.Limits.Descriptor; }
      }
      
      public override Limits DefaultInstanceForType {
        get { return global::core.Limits.DefaultInstance; }
      }
      
      public override Limits BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Limits) {
          return MergeFrom((Limits) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Limits other) {
        if (other == global::core.Limits.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasRelation) {
          Relation = other.Relation;
        }
        if (other.handleLimits_.Count != 0) {
          result.handleLimits_.Add(other.handleLimits_);
        }
        if (other.targetLimits_.Count != 0) {
          result.targetLimits_.Add(other.targetLimits_);
        }
        if (other.HasStand) {
          Stand = other.Stand;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_limitsFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _limitsFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasRelation = input.ReadString(ref result.relation_);
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.handleLimits_, global::core.LimitValue.DefaultInstance, extensionRegistry);
              break;
            }
            case 26: {
              input.ReadMessageArray(tag, field_name, result.targetLimits_, global::core.LimitValue.DefaultInstance, extensionRegistry);
              break;
            }
            case 32: {
              result.hasStand = input.ReadInt32(ref result.stand_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasRelation {
        get { return result.hasRelation; }
      }
      public string Relation {
        get { return result.Relation; }
        set { SetRelation(value); }
      }
      public Builder SetRelation(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRelation = true;
        result.relation_ = value;
        return this;
      }
      public Builder ClearRelation() {
        PrepareBuilder();
        result.hasRelation = false;
        result.relation_ = "";
        return this;
      }
      
      public pbc::IPopsicleList<global::core.LimitValue> HandleLimitsList {
        get { return PrepareBuilder().handleLimits_; }
      }
      public int HandleLimitsCount {
        get { return result.HandleLimitsCount; }
      }
      public global::core.LimitValue GetHandleLimits(int index) {
        return result.GetHandleLimits(index);
      }
      public Builder SetHandleLimits(int index, global::core.LimitValue value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.handleLimits_[index] = value;
        return this;
      }
      public Builder SetHandleLimits(int index, global::core.LimitValue.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.handleLimits_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddHandleLimits(global::core.LimitValue value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.handleLimits_.Add(value);
        return this;
      }
      public Builder AddHandleLimits(global::core.LimitValue.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.handleLimits_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeHandleLimits(scg::IEnumerable<global::core.LimitValue> values) {
        PrepareBuilder();
        result.handleLimits_.Add(values);
        return this;
      }
      public Builder ClearHandleLimits() {
        PrepareBuilder();
        result.handleLimits_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::core.LimitValue> TargetLimitsList {
        get { return PrepareBuilder().targetLimits_; }
      }
      public int TargetLimitsCount {
        get { return result.TargetLimitsCount; }
      }
      public global::core.LimitValue GetTargetLimits(int index) {
        return result.GetTargetLimits(index);
      }
      public Builder SetTargetLimits(int index, global::core.LimitValue value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.targetLimits_[index] = value;
        return this;
      }
      public Builder SetTargetLimits(int index, global::core.LimitValue.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.targetLimits_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddTargetLimits(global::core.LimitValue value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.targetLimits_.Add(value);
        return this;
      }
      public Builder AddTargetLimits(global::core.LimitValue.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.targetLimits_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeTargetLimits(scg::IEnumerable<global::core.LimitValue> values) {
        PrepareBuilder();
        result.targetLimits_.Add(values);
        return this;
      }
      public Builder ClearTargetLimits() {
        PrepareBuilder();
        result.targetLimits_.Clear();
        return this;
      }
      
      public bool HasStand {
        get { return result.hasStand; }
      }
      public int Stand {
        get { return result.Stand; }
        set { SetStand(value); }
      }
      public Builder SetStand(int value) {
        PrepareBuilder();
        result.hasStand = true;
        result.stand_ = value;
        return this;
      }
      public Builder ClearStand() {
        PrepareBuilder();
        result.hasStand = false;
        result.stand_ = 0;
        return this;
      }
    }
    static Limits() {
      object.ReferenceEquals(global::core.System.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class EffectValue : pb::GeneratedMessage<EffectValue, EffectValue.Builder> {
    private EffectValue() { }
    private static readonly EffectValue defaultInstance = new EffectValue().MakeReadOnly();
    private static readonly string[] _effectValueFieldNames = new string[] { "field_name", "op", "script", "type", "value" };
    private static readonly uint[] _effectValueFieldTags = new uint[] { 10, 16, 34, 24, 45 };
    public static EffectValue DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override EffectValue DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override EffectValue ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::core.System.internal__static_core_EffectValue__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<EffectValue, EffectValue.Builder> InternalFieldAccessors {
      get { return global::core.System.internal__static_core_EffectValue__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public static class Types {
      [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
      [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
      public enum Op {
        Add = 0,
        PersentAdd = 1,
        FieldPersentAdd = 2,
        Replace = 3,
        Prefix = 4,
        Postfix = 5,
        AddFlag = 6,
        DelFlag = 7,
      }
      
      [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
      [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
      public enum Type {
        Constant = 0,
        Script = 1,
        State = 2,
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
      [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
      public sealed partial class ScriptParam : pb::GeneratedMessage<ScriptParam, ScriptParam.Builder> {
        private ScriptParam() { }
        private static readonly ScriptParam defaultInstance = new ScriptParam().MakeReadOnly();
        private static readonly string[] _scriptParamFieldNames = new string[] { "p" };
        private static readonly uint[] _scriptParamFieldTags = new uint[] { 13 };
        public static ScriptParam DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override ScriptParam DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override ScriptParam ThisMessage {
          get { return this; }
        }
        
        public static pbd::MessageDescriptor Descriptor {
          get { return global::core.System.internal__static_core_EffectValue_ScriptParam__Descriptor; }
        }
        
        protected override pb::FieldAccess.FieldAccessorTable<ScriptParam, ScriptParam.Builder> InternalFieldAccessors {
          get { return global::core.System.internal__static_core_EffectValue_ScriptParam__FieldAccessorTable; }
        }
        
        public const int PFieldNumber = 1;
        private pbc::PopsicleList<float> p_ = new pbc::PopsicleList<float>();
        public scg::IList<float> PList {
          get { return pbc::Lists.AsReadOnly(p_); }
        }
        public int PCount {
          get { return p_.Count; }
        }
        public float GetP(int index) {
          return p_[index];
        }
        
        public override bool IsInitialized {
          get {
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          int size = SerializedSize;
          string[] field_names = _scriptParamFieldNames;
          if (p_.Count > 0) {
            output.WriteFloatArray(1, field_names[0], p_);
          }
          UnknownFields.WriteTo(output);
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            {
              int dataSize = 0;
              dataSize = 4 * p_.Count;
              size += dataSize;
              size += 1 * p_.Count;
            }
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
          }
        }
        
        public static ScriptParam ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static ScriptParam ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static ScriptParam ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static ScriptParam ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static ScriptParam ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static ScriptParam ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static ScriptParam ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static ScriptParam ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static ScriptParam ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static ScriptParam ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private ScriptParam MakeReadOnly() {
          p_.MakeReadOnly();
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(ScriptParam prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
        public sealed partial class Builder : pb::GeneratedBuilder<ScriptParam, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(ScriptParam cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private ScriptParam result;
          
          private ScriptParam PrepareBuilder() {
            if (resultIsReadOnly) {
              ScriptParam original = result;
              result = new ScriptParam();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override ScriptParam MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override pbd::MessageDescriptor DescriptorForType {
            get { return global::core.EffectValue.Types.ScriptParam.Descriptor; }
          }
          
          public override ScriptParam DefaultInstanceForType {
            get { return global::core.EffectValue.Types.ScriptParam.DefaultInstance; }
          }
          
          public override ScriptParam BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessage other) {
            if (other is ScriptParam) {
              return MergeFrom((ScriptParam) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(ScriptParam other) {
            if (other == global::core.EffectValue.Types.ScriptParam.DefaultInstance) return this;
            PrepareBuilder();
            if (other.p_.Count != 0) {
              result.p_.Add(other.p_);
            }
            this.MergeUnknownFields(other.UnknownFields);
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            pb::UnknownFieldSet.Builder unknownFields = null;
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_scriptParamFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _scriptParamFieldTags[field_ordinal];
                else {
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    if (unknownFields != null) {
                      this.UnknownFields = unknownFields.Build();
                    }
                    return this;
                  }
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                  break;
                }
                case 10:
                case 13: {
                  input.ReadFloatArray(tag, field_name, result.p_);
                  break;
                }
              }
            }
            
            if (unknownFields != null) {
              this.UnknownFields = unknownFields.Build();
            }
            return this;
          }
          
          
          public pbc::IPopsicleList<float> PList {
            get { return PrepareBuilder().p_; }
          }
          public int PCount {
            get { return result.PCount; }
          }
          public float GetP(int index) {
            return result.GetP(index);
          }
          public Builder SetP(int index, float value) {
            PrepareBuilder();
            result.p_[index] = value;
            return this;
          }
          public Builder AddP(float value) {
            PrepareBuilder();
            result.p_.Add(value);
            return this;
          }
          public Builder AddRangeP(scg::IEnumerable<float> values) {
            PrepareBuilder();
            result.p_.Add(values);
            return this;
          }
          public Builder ClearP() {
            PrepareBuilder();
            result.p_.Clear();
            return this;
          }
        }
        static ScriptParam() {
          object.ReferenceEquals(global::core.System.Descriptor, null);
        }
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
      [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
      public sealed partial class ScriptFunc : pb::GeneratedMessage<ScriptFunc, ScriptFunc.Builder> {
        private ScriptFunc() { }
        private static readonly ScriptFunc defaultInstance = new ScriptFunc().MakeReadOnly();
        private static readonly string[] _scriptFuncFieldNames = new string[] { "function", "params" };
        private static readonly uint[] _scriptFuncFieldTags = new uint[] { 10, 18 };
        public static ScriptFunc DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override ScriptFunc DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override ScriptFunc ThisMessage {
          get { return this; }
        }
        
        public static pbd::MessageDescriptor Descriptor {
          get { return global::core.System.internal__static_core_EffectValue_ScriptFunc__Descriptor; }
        }
        
        protected override pb::FieldAccess.FieldAccessorTable<ScriptFunc, ScriptFunc.Builder> InternalFieldAccessors {
          get { return global::core.System.internal__static_core_EffectValue_ScriptFunc__FieldAccessorTable; }
        }
        
        public const int FunctionFieldNumber = 1;
        private bool hasFunction;
        private string function_ = "";
        public bool HasFunction {
          get { return hasFunction; }
        }
        public string Function {
          get { return function_; }
        }
        
        public const int ParamsFieldNumber = 2;
        private pbc::PopsicleList<global::core.EffectValue.Types.ScriptParam> params_ = new pbc::PopsicleList<global::core.EffectValue.Types.ScriptParam>();
        public scg::IList<global::core.EffectValue.Types.ScriptParam> ParamsList {
          get { return params_; }
        }
        public int ParamsCount {
          get { return params_.Count; }
        }
        public global::core.EffectValue.Types.ScriptParam GetParams(int index) {
          return params_[index];
        }
        
        public override bool IsInitialized {
          get {
            if (!hasFunction) return false;
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          int size = SerializedSize;
          string[] field_names = _scriptFuncFieldNames;
          if (hasFunction) {
            output.WriteString(1, field_names[0], Function);
          }
          if (params_.Count > 0) {
            output.WriteMessageArray(2, field_names[1], params_);
          }
          UnknownFields.WriteTo(output);
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasFunction) {
              size += pb::CodedOutputStream.ComputeStringSize(1, Function);
            }
            foreach (global::core.EffectValue.Types.ScriptParam element in ParamsList) {
              size += pb::CodedOutputStream.ComputeMessageSize(2, element);
            }
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
          }
        }
        
        public static ScriptFunc ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static ScriptFunc ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static ScriptFunc ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static ScriptFunc ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static ScriptFunc ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static ScriptFunc ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static ScriptFunc ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static ScriptFunc ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static ScriptFunc ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static ScriptFunc ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private ScriptFunc MakeReadOnly() {
          params_.MakeReadOnly();
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(ScriptFunc prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
        public sealed partial class Builder : pb::GeneratedBuilder<ScriptFunc, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(ScriptFunc cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private ScriptFunc result;
          
          private ScriptFunc PrepareBuilder() {
            if (resultIsReadOnly) {
              ScriptFunc original = result;
              result = new ScriptFunc();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override ScriptFunc MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override pbd::MessageDescriptor DescriptorForType {
            get { return global::core.EffectValue.Types.ScriptFunc.Descriptor; }
          }
          
          public override ScriptFunc DefaultInstanceForType {
            get { return global::core.EffectValue.Types.ScriptFunc.DefaultInstance; }
          }
          
          public override ScriptFunc BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessage other) {
            if (other is ScriptFunc) {
              return MergeFrom((ScriptFunc) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(ScriptFunc other) {
            if (other == global::core.EffectValue.Types.ScriptFunc.DefaultInstance) return this;
            PrepareBuilder();
            if (other.HasFunction) {
              Function = other.Function;
            }
            if (other.params_.Count != 0) {
              result.params_.Add(other.params_);
            }
            this.MergeUnknownFields(other.UnknownFields);
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            pb::UnknownFieldSet.Builder unknownFields = null;
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_scriptFuncFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _scriptFuncFieldTags[field_ordinal];
                else {
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    if (unknownFields != null) {
                      this.UnknownFields = unknownFields.Build();
                    }
                    return this;
                  }
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                  break;
                }
                case 10: {
                  result.hasFunction = input.ReadString(ref result.function_);
                  break;
                }
                case 18: {
                  input.ReadMessageArray(tag, field_name, result.params_, global::core.EffectValue.Types.ScriptParam.DefaultInstance, extensionRegistry);
                  break;
                }
              }
            }
            
            if (unknownFields != null) {
              this.UnknownFields = unknownFields.Build();
            }
            return this;
          }
          
          
          public bool HasFunction {
            get { return result.hasFunction; }
          }
          public string Function {
            get { return result.Function; }
            set { SetFunction(value); }
          }
          public Builder SetFunction(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasFunction = true;
            result.function_ = value;
            return this;
          }
          public Builder ClearFunction() {
            PrepareBuilder();
            result.hasFunction = false;
            result.function_ = "";
            return this;
          }
          
          public pbc::IPopsicleList<global::core.EffectValue.Types.ScriptParam> ParamsList {
            get { return PrepareBuilder().params_; }
          }
          public int ParamsCount {
            get { return result.ParamsCount; }
          }
          public global::core.EffectValue.Types.ScriptParam GetParams(int index) {
            return result.GetParams(index);
          }
          public Builder SetParams(int index, global::core.EffectValue.Types.ScriptParam value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.params_[index] = value;
            return this;
          }
          public Builder SetParams(int index, global::core.EffectValue.Types.ScriptParam.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.params_[index] = builderForValue.Build();
            return this;
          }
          public Builder AddParams(global::core.EffectValue.Types.ScriptParam value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.params_.Add(value);
            return this;
          }
          public Builder AddParams(global::core.EffectValue.Types.ScriptParam.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.params_.Add(builderForValue.Build());
            return this;
          }
          public Builder AddRangeParams(scg::IEnumerable<global::core.EffectValue.Types.ScriptParam> values) {
            PrepareBuilder();
            result.params_.Add(values);
            return this;
          }
          public Builder ClearParams() {
            PrepareBuilder();
            result.params_.Clear();
            return this;
          }
        }
        static ScriptFunc() {
          object.ReferenceEquals(global::core.System.Descriptor, null);
        }
      }
      
    }
    #endregion
    
    public const int FieldNameFieldNumber = 1;
    private bool hasFieldName;
    private string fieldName_ = "";
    public bool HasFieldName {
      get { return hasFieldName; }
    }
    public string FieldName {
      get { return fieldName_; }
    }
    
    public const int OpFieldNumber = 2;
    private bool hasOp;
    private global::core.EffectValue.Types.Op op_ = global::core.EffectValue.Types.Op.Add;
    public bool HasOp {
      get { return hasOp; }
    }
    public global::core.EffectValue.Types.Op Op {
      get { return op_; }
    }
    
    public const int TypeFieldNumber = 3;
    private bool hasType;
    private global::core.EffectValue.Types.Type type_ = global::core.EffectValue.Types.Type.Constant;
    public bool HasType {
      get { return hasType; }
    }
    public global::core.EffectValue.Types.Type Type {
      get { return type_; }
    }
    
    public const int ScriptFieldNumber = 4;
    private bool hasScript;
    private global::core.EffectValue.Types.ScriptFunc script_;
    public bool HasScript {
      get { return hasScript; }
    }
    public global::core.EffectValue.Types.ScriptFunc Script {
      get { return script_ ?? global::core.EffectValue.Types.ScriptFunc.DefaultInstance; }
    }
    
    public const int ValueFieldNumber = 5;
    private pbc::PopsicleList<float> value_ = new pbc::PopsicleList<float>();
    public scg::IList<float> ValueList {
      get { return pbc::Lists.AsReadOnly(value_); }
    }
    public int ValueCount {
      get { return value_.Count; }
    }
    public float GetValue(int index) {
      return value_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasFieldName) return false;
        if (!hasOp) return false;
        if (!hasType) return false;
        if (HasScript) {
          if (!Script.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _effectValueFieldNames;
      if (hasFieldName) {
        output.WriteString(1, field_names[0], FieldName);
      }
      if (hasOp) {
        output.WriteEnum(2, field_names[1], (int) Op, Op);
      }
      if (hasType) {
        output.WriteEnum(3, field_names[3], (int) Type, Type);
      }
      if (hasScript) {
        output.WriteMessage(4, field_names[2], Script);
      }
      if (value_.Count > 0) {
        output.WriteFloatArray(5, field_names[4], value_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasFieldName) {
          size += pb::CodedOutputStream.ComputeStringSize(1, FieldName);
        }
        if (hasOp) {
          size += pb::CodedOutputStream.ComputeEnumSize(2, (int) Op);
        }
        if (hasType) {
          size += pb::CodedOutputStream.ComputeEnumSize(3, (int) Type);
        }
        if (hasScript) {
          size += pb::CodedOutputStream.ComputeMessageSize(4, Script);
        }
        {
          int dataSize = 0;
          dataSize = 4 * value_.Count;
          size += dataSize;
          size += 1 * value_.Count;
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static EffectValue ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EffectValue ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EffectValue ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EffectValue ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EffectValue ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EffectValue ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static EffectValue ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static EffectValue ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static EffectValue ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EffectValue ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private EffectValue MakeReadOnly() {
      value_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(EffectValue prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<EffectValue, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(EffectValue cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EffectValue result;
      
      private EffectValue PrepareBuilder() {
        if (resultIsReadOnly) {
          EffectValue original = result;
          result = new EffectValue();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override EffectValue MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::core.EffectValue.Descriptor; }
      }
      
      public override EffectValue DefaultInstanceForType {
        get { return global::core.EffectValue.DefaultInstance; }
      }
      
      public override EffectValue BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is EffectValue) {
          return MergeFrom((EffectValue) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(EffectValue other) {
        if (other == global::core.EffectValue.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasFieldName) {
          FieldName = other.FieldName;
        }
        if (other.HasOp) {
          Op = other.Op;
        }
        if (other.HasType) {
          Type = other.Type;
        }
        if (other.HasScript) {
          MergeScript(other.Script);
        }
        if (other.value_.Count != 0) {
          result.value_.Add(other.value_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_effectValueFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _effectValueFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasFieldName = input.ReadString(ref result.fieldName_);
              break;
            }
            case 16: {
              object unknown;
              if(input.ReadEnum(ref result.op_, out unknown)) {
                result.hasOp = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(2, (ulong)(int)unknown);
              }
              break;
            }
            case 24: {
              object unknown;
              if(input.ReadEnum(ref result.type_, out unknown)) {
                result.hasType = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(3, (ulong)(int)unknown);
              }
              break;
            }
            case 34: {
              global::core.EffectValue.Types.ScriptFunc.Builder subBuilder = global::core.EffectValue.Types.ScriptFunc.CreateBuilder();
              if (result.hasScript) {
                subBuilder.MergeFrom(Script);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Script = subBuilder.BuildPartial();
              break;
            }
            case 42:
            case 45: {
              input.ReadFloatArray(tag, field_name, result.value_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasFieldName {
        get { return result.hasFieldName; }
      }
      public string FieldName {
        get { return result.FieldName; }
        set { SetFieldName(value); }
      }
      public Builder SetFieldName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasFieldName = true;
        result.fieldName_ = value;
        return this;
      }
      public Builder ClearFieldName() {
        PrepareBuilder();
        result.hasFieldName = false;
        result.fieldName_ = "";
        return this;
      }
      
      public bool HasOp {
       get { return result.hasOp; }
      }
      public global::core.EffectValue.Types.Op Op {
        get { return result.Op; }
        set { SetOp(value); }
      }
      public Builder SetOp(global::core.EffectValue.Types.Op value) {
        PrepareBuilder();
        result.hasOp = true;
        result.op_ = value;
        return this;
      }
      public Builder ClearOp() {
        PrepareBuilder();
        result.hasOp = false;
        result.op_ = global::core.EffectValue.Types.Op.Add;
        return this;
      }
      
      public bool HasType {
       get { return result.hasType; }
      }
      public global::core.EffectValue.Types.Type Type {
        get { return result.Type; }
        set { SetType(value); }
      }
      public Builder SetType(global::core.EffectValue.Types.Type value) {
        PrepareBuilder();
        result.hasType = true;
        result.type_ = value;
        return this;
      }
      public Builder ClearType() {
        PrepareBuilder();
        result.hasType = false;
        result.type_ = global::core.EffectValue.Types.Type.Constant;
        return this;
      }
      
      public bool HasScript {
       get { return result.hasScript; }
      }
      public global::core.EffectValue.Types.ScriptFunc Script {
        get { return result.Script; }
        set { SetScript(value); }
      }
      public Builder SetScript(global::core.EffectValue.Types.ScriptFunc value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasScript = true;
        result.script_ = value;
        return this;
      }
      public Builder SetScript(global::core.EffectValue.Types.ScriptFunc.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasScript = true;
        result.script_ = builderForValue.Build();
        return this;
      }
      public Builder MergeScript(global::core.EffectValue.Types.ScriptFunc value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasScript &&
            result.script_ != global::core.EffectValue.Types.ScriptFunc.DefaultInstance) {
            result.script_ = global::core.EffectValue.Types.ScriptFunc.CreateBuilder(result.script_).MergeFrom(value).BuildPartial();
        } else {
          result.script_ = value;
        }
        result.hasScript = true;
        return this;
      }
      public Builder ClearScript() {
        PrepareBuilder();
        result.hasScript = false;
        result.script_ = null;
        return this;
      }
      
      public pbc::IPopsicleList<float> ValueList {
        get { return PrepareBuilder().value_; }
      }
      public int ValueCount {
        get { return result.ValueCount; }
      }
      public float GetValue(int index) {
        return result.GetValue(index);
      }
      public Builder SetValue(int index, float value) {
        PrepareBuilder();
        result.value_[index] = value;
        return this;
      }
      public Builder AddValue(float value) {
        PrepareBuilder();
        result.value_.Add(value);
        return this;
      }
      public Builder AddRangeValue(scg::IEnumerable<float> values) {
        PrepareBuilder();
        result.value_.Add(values);
        return this;
      }
      public Builder ClearValue() {
        PrepareBuilder();
        result.value_.Clear();
        return this;
      }
    }
    static EffectValue() {
      object.ReferenceEquals(global::core.System.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Effects : pb::GeneratedMessage<Effects, Effects.Builder> {
    private Effects() { }
    private static readonly Effects defaultInstance = new Effects().MakeReadOnly();
    private static readonly string[] _effectsFieldNames = new string[] { "effectors", "relation", "selectors" };
    private static readonly uint[] _effectsFieldTags = new uint[] { 18, 10, 26 };
    public static Effects DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Effects DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Effects ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::core.System.internal__static_core_Effects__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Effects, Effects.Builder> InternalFieldAccessors {
      get { return global::core.System.internal__static_core_Effects__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public static class Types {
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
      [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
      public sealed partial class Selector : pb::GeneratedMessage<Selector, Selector.Builder> {
        private Selector() { }
        private static readonly Selector defaultInstance = new Selector().MakeReadOnly();
        private static readonly string[] _selectorFieldNames = new string[] { "params", "type" };
        private static readonly uint[] _selectorFieldTags = new uint[] { 21, 8 };
        public static Selector DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override Selector DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override Selector ThisMessage {
          get { return this; }
        }
        
        public static pbd::MessageDescriptor Descriptor {
          get { return global::core.System.internal__static_core_Effects_Selector__Descriptor; }
        }
        
        protected override pb::FieldAccess.FieldAccessorTable<Selector, Selector.Builder> InternalFieldAccessors {
          get { return global::core.System.internal__static_core_Effects_Selector__FieldAccessorTable; }
        }
        
        #region Nested types
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
        public static class Types {
          [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
          [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
          public enum Type {
            Stand = 0,
            Space = 1,
            Attrib = 2,
          }
          
        }
        #endregion
        
        public const int TypeFieldNumber = 1;
        private bool hasType;
        private global::core.Effects.Types.Selector.Types.Type type_ = global::core.Effects.Types.Selector.Types.Type.Stand;
        public bool HasType {
          get { return hasType; }
        }
        public global::core.Effects.Types.Selector.Types.Type Type {
          get { return type_; }
        }
        
        public const int ParamsFieldNumber = 2;
        private pbc::PopsicleList<float> params_ = new pbc::PopsicleList<float>();
        public scg::IList<float> ParamsList {
          get { return pbc::Lists.AsReadOnly(params_); }
        }
        public int ParamsCount {
          get { return params_.Count; }
        }
        public float GetParams(int index) {
          return params_[index];
        }
        
        public override bool IsInitialized {
          get {
            if (!hasType) return false;
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          int size = SerializedSize;
          string[] field_names = _selectorFieldNames;
          if (hasType) {
            output.WriteEnum(1, field_names[1], (int) Type, Type);
          }
          if (params_.Count > 0) {
            output.WriteFloatArray(2, field_names[0], params_);
          }
          UnknownFields.WriteTo(output);
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasType) {
              size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Type);
            }
            {
              int dataSize = 0;
              dataSize = 4 * params_.Count;
              size += dataSize;
              size += 1 * params_.Count;
            }
            size += UnknownFields.SerializedSize;
            memoizedSerializedSize = size;
            return size;
          }
        }
        
        public static Selector ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Selector ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Selector ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Selector ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Selector ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Selector ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static Selector ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static Selector ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static Selector ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Selector ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private Selector MakeReadOnly() {
          params_.MakeReadOnly();
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(Selector prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
        public sealed partial class Builder : pb::GeneratedBuilder<Selector, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(Selector cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private Selector result;
          
          private Selector PrepareBuilder() {
            if (resultIsReadOnly) {
              Selector original = result;
              result = new Selector();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override Selector MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override pbd::MessageDescriptor DescriptorForType {
            get { return global::core.Effects.Types.Selector.Descriptor; }
          }
          
          public override Selector DefaultInstanceForType {
            get { return global::core.Effects.Types.Selector.DefaultInstance; }
          }
          
          public override Selector BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessage other) {
            if (other is Selector) {
              return MergeFrom((Selector) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(Selector other) {
            if (other == global::core.Effects.Types.Selector.DefaultInstance) return this;
            PrepareBuilder();
            if (other.HasType) {
              Type = other.Type;
            }
            if (other.params_.Count != 0) {
              result.params_.Add(other.params_);
            }
            this.MergeUnknownFields(other.UnknownFields);
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            pb::UnknownFieldSet.Builder unknownFields = null;
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_selectorFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _selectorFieldTags[field_ordinal];
                else {
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    if (unknownFields != null) {
                      this.UnknownFields = unknownFields.Build();
                    }
                    return this;
                  }
                  if (unknownFields == null) {
                    unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                  }
                  ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                  break;
                }
                case 8: {
                  object unknown;
                  if(input.ReadEnum(ref result.type_, out unknown)) {
                    result.hasType = true;
                  } else if(unknown is int) {
                    if (unknownFields == null) {
                      unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                    }
                    unknownFields.MergeVarintField(1, (ulong)(int)unknown);
                  }
                  break;
                }
                case 18:
                case 21: {
                  input.ReadFloatArray(tag, field_name, result.params_);
                  break;
                }
              }
            }
            
            if (unknownFields != null) {
              this.UnknownFields = unknownFields.Build();
            }
            return this;
          }
          
          
          public bool HasType {
           get { return result.hasType; }
          }
          public global::core.Effects.Types.Selector.Types.Type Type {
            get { return result.Type; }
            set { SetType(value); }
          }
          public Builder SetType(global::core.Effects.Types.Selector.Types.Type value) {
            PrepareBuilder();
            result.hasType = true;
            result.type_ = value;
            return this;
          }
          public Builder ClearType() {
            PrepareBuilder();
            result.hasType = false;
            result.type_ = global::core.Effects.Types.Selector.Types.Type.Stand;
            return this;
          }
          
          public pbc::IPopsicleList<float> ParamsList {
            get { return PrepareBuilder().params_; }
          }
          public int ParamsCount {
            get { return result.ParamsCount; }
          }
          public float GetParams(int index) {
            return result.GetParams(index);
          }
          public Builder SetParams(int index, float value) {
            PrepareBuilder();
            result.params_[index] = value;
            return this;
          }
          public Builder AddParams(float value) {
            PrepareBuilder();
            result.params_.Add(value);
            return this;
          }
          public Builder AddRangeParams(scg::IEnumerable<float> values) {
            PrepareBuilder();
            result.params_.Add(values);
            return this;
          }
          public Builder ClearParams() {
            PrepareBuilder();
            result.params_.Clear();
            return this;
          }
        }
        static Selector() {
          object.ReferenceEquals(global::core.System.Descriptor, null);
        }
      }
      
    }
    #endregion
    
    public const int RelationFieldNumber = 1;
    private bool hasRelation;
    private string relation_ = "";
    public bool HasRelation {
      get { return hasRelation; }
    }
    public string Relation {
      get { return relation_; }
    }
    
    public const int EffectorsFieldNumber = 2;
    private pbc::PopsicleList<global::core.EffectValue> effectors_ = new pbc::PopsicleList<global::core.EffectValue>();
    public scg::IList<global::core.EffectValue> EffectorsList {
      get { return effectors_; }
    }
    public int EffectorsCount {
      get { return effectors_.Count; }
    }
    public global::core.EffectValue GetEffectors(int index) {
      return effectors_[index];
    }
    
    public const int SelectorsFieldNumber = 3;
    private pbc::PopsicleList<global::core.Effects.Types.Selector> selectors_ = new pbc::PopsicleList<global::core.Effects.Types.Selector>();
    public scg::IList<global::core.Effects.Types.Selector> SelectorsList {
      get { return selectors_; }
    }
    public int SelectorsCount {
      get { return selectors_.Count; }
    }
    public global::core.Effects.Types.Selector GetSelectors(int index) {
      return selectors_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasRelation) return false;
        foreach (global::core.EffectValue element in EffectorsList) {
          if (!element.IsInitialized) return false;
        }
        foreach (global::core.Effects.Types.Selector element in SelectorsList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _effectsFieldNames;
      if (hasRelation) {
        output.WriteString(1, field_names[1], Relation);
      }
      if (effectors_.Count > 0) {
        output.WriteMessageArray(2, field_names[0], effectors_);
      }
      if (selectors_.Count > 0) {
        output.WriteMessageArray(3, field_names[2], selectors_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasRelation) {
          size += pb::CodedOutputStream.ComputeStringSize(1, Relation);
        }
        foreach (global::core.EffectValue element in EffectorsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(2, element);
        }
        foreach (global::core.Effects.Types.Selector element in SelectorsList) {
          size += pb::CodedOutputStream.ComputeMessageSize(3, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Effects ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Effects ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Effects ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Effects ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Effects ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Effects ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Effects ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Effects ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Effects ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Effects ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Effects MakeReadOnly() {
      effectors_.MakeReadOnly();
      selectors_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Effects prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Effects, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Effects cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Effects result;
      
      private Effects PrepareBuilder() {
        if (resultIsReadOnly) {
          Effects original = result;
          result = new Effects();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Effects MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::core.Effects.Descriptor; }
      }
      
      public override Effects DefaultInstanceForType {
        get { return global::core.Effects.DefaultInstance; }
      }
      
      public override Effects BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Effects) {
          return MergeFrom((Effects) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Effects other) {
        if (other == global::core.Effects.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasRelation) {
          Relation = other.Relation;
        }
        if (other.effectors_.Count != 0) {
          result.effectors_.Add(other.effectors_);
        }
        if (other.selectors_.Count != 0) {
          result.selectors_.Add(other.selectors_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_effectsFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _effectsFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasRelation = input.ReadString(ref result.relation_);
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.effectors_, global::core.EffectValue.DefaultInstance, extensionRegistry);
              break;
            }
            case 26: {
              input.ReadMessageArray(tag, field_name, result.selectors_, global::core.Effects.Types.Selector.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasRelation {
        get { return result.hasRelation; }
      }
      public string Relation {
        get { return result.Relation; }
        set { SetRelation(value); }
      }
      public Builder SetRelation(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRelation = true;
        result.relation_ = value;
        return this;
      }
      public Builder ClearRelation() {
        PrepareBuilder();
        result.hasRelation = false;
        result.relation_ = "";
        return this;
      }
      
      public pbc::IPopsicleList<global::core.EffectValue> EffectorsList {
        get { return PrepareBuilder().effectors_; }
      }
      public int EffectorsCount {
        get { return result.EffectorsCount; }
      }
      public global::core.EffectValue GetEffectors(int index) {
        return result.GetEffectors(index);
      }
      public Builder SetEffectors(int index, global::core.EffectValue value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.effectors_[index] = value;
        return this;
      }
      public Builder SetEffectors(int index, global::core.EffectValue.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.effectors_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddEffectors(global::core.EffectValue value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.effectors_.Add(value);
        return this;
      }
      public Builder AddEffectors(global::core.EffectValue.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.effectors_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeEffectors(scg::IEnumerable<global::core.EffectValue> values) {
        PrepareBuilder();
        result.effectors_.Add(values);
        return this;
      }
      public Builder ClearEffectors() {
        PrepareBuilder();
        result.effectors_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::core.Effects.Types.Selector> SelectorsList {
        get { return PrepareBuilder().selectors_; }
      }
      public int SelectorsCount {
        get { return result.SelectorsCount; }
      }
      public global::core.Effects.Types.Selector GetSelectors(int index) {
        return result.GetSelectors(index);
      }
      public Builder SetSelectors(int index, global::core.Effects.Types.Selector value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.selectors_[index] = value;
        return this;
      }
      public Builder SetSelectors(int index, global::core.Effects.Types.Selector.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.selectors_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddSelectors(global::core.Effects.Types.Selector value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.selectors_.Add(value);
        return this;
      }
      public Builder AddSelectors(global::core.Effects.Types.Selector.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.selectors_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeSelectors(scg::IEnumerable<global::core.Effects.Types.Selector> values) {
        PrepareBuilder();
        result.selectors_.Add(values);
        return this;
      }
      public Builder ClearSelectors() {
        PrepareBuilder();
        result.selectors_.Clear();
        return this;
      }
    }
    static Effects() {
      object.ReferenceEquals(global::core.System.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Container : pb::GeneratedMessage<Container, Container.Builder> {
    private Container() { }
    private static readonly Container defaultInstance = new Container().MakeReadOnly();
    private static readonly string[] _containerFieldNames = new string[] { "reference" };
    private static readonly uint[] _containerFieldTags = new uint[] { 10 };
    public static Container DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Container DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Container ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::core.System.internal__static_core_Container__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Container, Container.Builder> InternalFieldAccessors {
      get { return global::core.System.internal__static_core_Container__FieldAccessorTable; }
    }
    
    public const int ReferenceFieldNumber = 1;
    private pbc::PopsicleList<global::core.GUID> reference_ = new pbc::PopsicleList<global::core.GUID>();
    public scg::IList<global::core.GUID> ReferenceList {
      get { return reference_; }
    }
    public int ReferenceCount {
      get { return reference_.Count; }
    }
    public global::core.GUID GetReference(int index) {
      return reference_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::core.GUID element in ReferenceList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _containerFieldNames;
      if (reference_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], reference_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        foreach (global::core.GUID element in ReferenceList) {
          size += pb::CodedOutputStream.ComputeMessageSize(1, element);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Container ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Container ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Container ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Container ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Container ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Container ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Container ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Container ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Container ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Container ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Container MakeReadOnly() {
      reference_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Container prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Container, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Container cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Container result;
      
      private Container PrepareBuilder() {
        if (resultIsReadOnly) {
          Container original = result;
          result = new Container();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Container MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::core.Container.Descriptor; }
      }
      
      public override Container DefaultInstanceForType {
        get { return global::core.Container.DefaultInstance; }
      }
      
      public override Container BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Container) {
          return MergeFrom((Container) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Container other) {
        if (other == global::core.Container.DefaultInstance) return this;
        PrepareBuilder();
        if (other.reference_.Count != 0) {
          result.reference_.Add(other.reference_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_containerFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _containerFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.reference_, global::core.GUID.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::core.GUID> ReferenceList {
        get { return PrepareBuilder().reference_; }
      }
      public int ReferenceCount {
        get { return result.ReferenceCount; }
      }
      public global::core.GUID GetReference(int index) {
        return result.GetReference(index);
      }
      public Builder SetReference(int index, global::core.GUID value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.reference_[index] = value;
        return this;
      }
      public Builder SetReference(int index, global::core.GUID.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.reference_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddReference(global::core.GUID value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.reference_.Add(value);
        return this;
      }
      public Builder AddReference(global::core.GUID.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.reference_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeReference(scg::IEnumerable<global::core.GUID> values) {
        PrepareBuilder();
        result.reference_.Add(values);
        return this;
      }
      public Builder ClearReference() {
        PrepareBuilder();
        result.reference_.Clear();
        return this;
      }
    }
    static Container() {
      object.ReferenceEquals(global::core.System.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class Respon : pb::GeneratedMessage<Respon, Respon.Builder> {
    private Respon() { }
    private static readonly Respon defaultInstance = new Respon().MakeReadOnly();
    private static readonly string[] _responFieldNames = new string[] { "result" };
    private static readonly uint[] _responFieldTags = new uint[] { 8 };
    public static Respon DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Respon DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Respon ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::core.System.internal__static_core_Respon__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Respon, Respon.Builder> InternalFieldAccessors {
      get { return global::core.System.internal__static_core_Respon__FieldAccessorTable; }
    }
    
    public const int ResultFieldNumber = 1;
    private bool hasResult;
    private int result_;
    public bool HasResult {
      get { return hasResult; }
    }
    public int Result {
      get { return result_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasResult) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _responFieldNames;
      if (hasResult) {
        output.WriteInt32(1, field_names[0], Result);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasResult) {
          size += pb::CodedOutputStream.ComputeInt32Size(1, Result);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Respon ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Respon ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Respon ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Respon ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Respon ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Respon ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Respon ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Respon ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Respon ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Respon ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Respon MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Respon prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<Respon, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Respon cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Respon result;
      
      private Respon PrepareBuilder() {
        if (resultIsReadOnly) {
          Respon original = result;
          result = new Respon();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Respon MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::core.Respon.Descriptor; }
      }
      
      public override Respon DefaultInstanceForType {
        get { return global::core.Respon.DefaultInstance; }
      }
      
      public override Respon BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Respon) {
          return MergeFrom((Respon) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Respon other) {
        if (other == global::core.Respon.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasResult) {
          Result = other.Result;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_responFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _responFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasResult = input.ReadInt32(ref result.result_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasResult {
        get { return result.hasResult; }
      }
      public int Result {
        get { return result.Result; }
        set { SetResult(value); }
      }
      public Builder SetResult(int value) {
        PrepareBuilder();
        result.hasResult = true;
        result.result_ = value;
        return this;
      }
      public Builder ClearResult() {
        PrepareBuilder();
        result.hasResult = false;
        result.result_ = 0;
        return this;
      }
    }
    static Respon() {
      object.ReferenceEquals(global::core.System.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
  public sealed partial class NullRequst : pb::GeneratedMessage<NullRequst, NullRequst.Builder> {
    private NullRequst() { }
    private static readonly NullRequst defaultInstance = new NullRequst().MakeReadOnly();
    private static readonly string[] _nullRequstFieldNames = new string[] {  };
    private static readonly uint[] _nullRequstFieldTags = new uint[] {  };
    public static NullRequst DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override NullRequst DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override NullRequst ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::core.System.internal__static_core_NullRequst__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<NullRequst, NullRequst.Builder> InternalFieldAccessors {
      get { return global::core.System.internal__static_core_NullRequst__FieldAccessorTable; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _nullRequstFieldNames;
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static NullRequst ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static NullRequst ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static NullRequst ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static NullRequst ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static NullRequst ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static NullRequst ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static NullRequst ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static NullRequst ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static NullRequst ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static NullRequst ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private NullRequst MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(NullRequst prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ProtoGen", "2.4.1.473")]
    public sealed partial class Builder : pb::GeneratedBuilder<NullRequst, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(NullRequst cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private NullRequst result;
      
      private NullRequst PrepareBuilder() {
        if (resultIsReadOnly) {
          NullRequst original = result;
          result = new NullRequst();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override NullRequst MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::core.NullRequst.Descriptor; }
      }
      
      public override NullRequst DefaultInstanceForType {
        get { return global::core.NullRequst.DefaultInstance; }
      }
      
      public override NullRequst BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is NullRequst) {
          return MergeFrom((NullRequst) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(NullRequst other) {
        if (other == global::core.NullRequst.DefaultInstance) return this;
        PrepareBuilder();
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_nullRequstFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _nullRequstFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
    }
    static NullRequst() {
      object.ReferenceEquals(global::core.System.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
